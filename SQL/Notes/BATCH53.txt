oracle :- 
------------

 1  SQL (structured query language)
 2  PL/SQL  (procedural language / sql)

SQL databases :-
------------------------

 oracle
 sql server
 mysql
 postgresql 

NoSQL database :-
-------------------------
 mongodb 

   Database :- 
   ---------------

  => a db is a organized collection of interrelated data.
       for ex a bank db stores data related to customers,
       accounts and transactions etc and a univ db stores 
       data related to students,courses and faculty etc.

  Types of Databases :- 
  --------------------------------

 1  OLTP  DB (online transaction processing)
 2  OLAP DB  (online analytical processing) 
 
=> organizations uses OLTP db for storing day-to-day transactions
     and OLAP for analysis.

 => OLTP is for running business and OLAP is for to analyze business.


oltp :-

 cust
 cid	name	addr
 1000	sachin	mum

olap :- 

 cust	name	addr	start_date		end_date
 1000	sachin	hyd	2020		2022-
 1000	sachin	blr	2023		2024
 1000	sachin	mum	2025
       
=> day-to-day operations on db includes 
 
	C    create
	R    read
	U    update
	D    delete 

DBMS :- 
 -----------

 => DBMS stands for Database Management System
 => DBMS is a software used to create and to work with db 
 => DBMS is an interface between user and database.

          USER-----------DBMS---------------DB

Evolution of DBMS (Types of DBMS) :- 
----------------------------------------------------

	1960		fms   (file mgmt system)

	1970		hdbms (hierarchical dbms)
			ndbms (network dbms)

	1980		rdbms  (relational dbms)
	
	1990		ordbms (object relational dbms)

  RDBMS :- 
  --------------

  => RDBMS stands for relational database management system
  => rdbms concepts introduced by E.F.CODD
  => E.F.CODD introduced 12 rules called codd rules 
  => a db software that supports all 12 rules is called perfect rdbms

 information rule :- 
 --------------------------

  => according to information rule data must be organized in tables i.e. rows and columns

  
cust 
   cid	name	addr  =>  columns / fields / attributes 
   100	sachin	hyd
   101	rahul	mum
   102	vijay	del  => row / record / tuple

   DB =  collection of tables 
   TABLE = collection of rows and columns
   ROW  =  collection of field values 
   COLUMN = collection of same field values 

 => every table must contain primary key to uniquely identify the rows 
  
     ex :-  empid,accno,aadharno,panno,voterid
 
=> one table related to another table using foreign key 

   PROJECTS
   projid   pname   duration       cost    client	
    1000    ABC       5             300    TATA MOTORS
    1001    KLM       3             200     KLM 
    1002    PQR      4             400     L&T

  EMP
  empid	ename	job	sal	projid    => foreign key
  100		SE	40K	1000
  101		SSE	50K	1001
  102		TL	80K	1002

  RDBMS features :-  
  --------------------------

 1 easy to access (R) and manipulate ( C,U,D) data 
 2 less redundency (duplication of data)
 3  more security
 4 gurantees data quality
 5 supports data sharing
 6 supports transactions (ACID properties)

        A    atomocity
        C     consistency
        I      isolation
        D     durability
  
 RDBMS softwares :- 
 ------------------------

 SQL Databases :- 
 ------------------------

 ORACLE		 from oracle corp
 MYSQL		 from oracle corp
 SQL SERVER	 from microsoft
 POSTGRESQL	 from postgresql forum
 RDS		 from amazon

 NoSQL Databases :- 
 -----------------------------
 MongoDB
 cassandra
 
ORDBMS :- 
----------------

=> object relational dbms 
=> It is the combination of rdbms & oops
 
              ordbms  =  rdbms + oops (reusability)

 => rdbms doesn't support reusability but ordbms supports reusability

 RDBMS :- 
 -------------

 cust
 cid	name	hno	street	city	state	pin

student
sno	sname	hno	street	city	state	pin

emp
empid	ename	hno	street	city	state	pin

ORDBMS :- 
-----------------

ADDR
hno	street	city	state	pin

CUST
cid	cname	addr

STUDENT
sid	sname	addr

EMP
empid	ename	addr

ORDBMS softwares :-
-----------------------------

 oracle 
 postgresql
 sql server
 mysql

DB Development Life Cycle :- 
----------------------------------------

Analysis
Design
Development
Testing
 Implementation / Deployment
 Maintenance

 Design :- 
 -------------

  => Designing db means designing tables
  => DB is designed by DB Designers & Architects 
  => DB is designed by using

     1   ER Model  (Entity Relationship)
     2   Normalization 

 Development :- 
 ----------------------

 => db is developed by DB Developers & DBAs
 => DB is developed by using any rdbms tools like oracle
 
 	Developers			DBAs

	creating tables			installation of oracle		
	creating views			creating database
	creating synonyms			creating logins for users		
	creating sequences			db backup & restore
	creating indexes			db export & import 	
	creating procedures
	creating functions
	creating triggers
	writing queries

Testing :- 
--------------

 => DB is tested by QA (Quality Analyst) team by 

         1   manual testing
         2   automation testing 

Deployment :-
-------------------

 => deploying db means moving db from DEV server to PROD server
 => after deploying db end users can use db for day-to-day operations
 => oracle db can be deployed in two ways 

 1  on premises
 2  on cloud

 => in  " on premises "  oracle db is deployed in server managed by  client.

 => from 12c onwards oracle db can also be deployed in cloud server  managed by 
      cloud service provider for ex amazon.
  
 summary :- 

 what is db ?
 what is dbms ?
 what is rdbms ?
 what is ordbms ?
 what is db development life cycle ? 

===========================================================================

 			 ORACLE
			 ========

  => oracle is  basically a rdbms software and also supports ordbms features and
       used to create and to manage database.

  => oracle can be used for db development and administration

versions of oracle :- 
-----------------------------

   2,3,4,5,6,7,8i,9i,10g,11g,12c,18c,19c,21c,23ai

                              		i  => internet
                              		g  => grid
                                  c  => cloud
                                 ai => artificial intelligence
	
   => from  "8i" onwards oracle db can used for web applications 
   => g stands for grid , from 10g onwards oracle db can be accessed through
        multiple servers (grid) and advantage of grid is it improves db availability.
   => c stands for cloud , from 12c onwards oracle db can be deployed in 
        cloud server

CLIENT / SERVER Architecture :- 
==========================

 1 SERVER
 2 CLIENT

 server :- 
 -----------

 => server is a system where oracle is installed and running
 => server manages two memories

   1 DB
   2 INSTANCE

  => DB is created in harddisk and acts as permanent storage
 => INSTANCE is created in ram and acts as temporary storage
 => data temporarly stored in instance and after saving it is copied to db.

 client :- 
 -----------

  => client is also a system from where users can 

    1  connects to server
    2  submit requests to server
    3  receive response from server

 client tool :- 
 ---------------

1  sqlplus    (CUI based)
2  sql developer  (GUI based)
 
 user-------sqlplus-------------------------------oracle--------------db

 user-----mysqlworkbench--------------------mysql--------------db

6-oct-25 

 SQL :- 
 ----------

 => SQL stands for structured query language
 => It is a language used to communicate with oracle
 => user communicates with oracle by sending commands called queries.
 => a query is a command / instruction / question given to oracle to perform 
      some operation on db.
 => SQL is originally introduced by IBM and initial name of this language was
       "SEQUEL"  and later it is renamed to SQL.
 => SQL is common to all rdbms database softwares 

      user-----sqlplus---------------------sql----------------------oracle------------db

      user-----mysqlworkbench----------sql------------------mysql-----------db

      user-------ssms------------------------sql------------------sql server-------db

 => based on operations SQL is categorized into following 5 sublanguages 

 	DDL           (Data Definition Lang)
	DML           (Data Manipulation Lang)
	DQL / DRL (Data Query Lang / Data Retrieval Lang)
	TCL            (Transaction Control Lang)
	DCL            (Data Control Lang)

 			SQL

	DDL	DML	DQL	TCL	DCL
		
	create	insert	select	commit	grant
	alter	update		rollback	revoke
	drop	delete		savepoint
	truncate	merge
	rename
	flashback
	purge

  => SQL commands are not case sensitive
  => commands must be terminated with ';' 
 
 SCHEMA :- 
 ---------------

 => schema means user 
 => a user in oracle db is called schema
 
  SERVER
         DATABASE
                     USER
                            TABLE 
                                      DATA 

 SERVER
         ORCL
              SYS / MANAGER	            DBA
              SYSTEM /MANAGER             DBA

 How to connect to oracle :- 
------------------------------------

 => open sqlplus and enter username and password

                USERNAME   :-  SYSTEM
                PASSWORD   :-  MANAGER

                OR

                 USERNAME :-    SYSTEM / MANAGER

creating user/schema/account :- 
--------------------------------------------

 => only DBAs are having permissions to create new user

 step 1 :-   connect as DBA 

     USERNAME :-   SYSTEM
     PASSWORD :-   MANAGER

 step 2 :-   create user 

  syntax :- 
  ------------

   CREATE USER  <NAME>  IDENTIFIED BY <PWD>
   DEFAULT TABLESPACE USERS
   QUOTA  UNLIMITED ON USERS ; 
 
Ex :- 

  SQL>CREATE USER BATCH53 IDENTIFIED BY ORACLE
           DEFAULT TABLESPACE USERS
           QUOTA UNLIMITED ON USERS ; 

    note :- user "BATCH53" can use unlimited memory in users tablespace

 step 3 :-  granting permissions to user

   SQL>GRANT CONNECT,RESOURCE TO BATCH53 ; 

                    connect    =>    to connect to db
                    resource   =>   to create objects like tables etc
                    dba           =>   all permissions 

     note :- if connect,resource are granted then user is called normal user
                if dba permission is granted then user is called admin

 changing password :- 
 -----------------------------

 => both user & dba can change password 

 1   by user  (BATCH53/ORACLE)

 SQL>PASSWORD
Changing password for BATCH53
Old password:  ORACLE
New password: NARESH
Retype new password: NARESH
Password changed  

 2   by  admin  (SYSTEM/MANAGER)

  SQL>ALTER USER BATCH53 IDENTIFIED BY TIGER ; 
   
Download & Install :- 
------------------------------

 download :- 
 ---------------

 https://www.oracle.com/in/database/technologies/xe-downloads.html

1  create a folder on desktop (for ex  oracle21c)
2  copy zip file from downloads to oracle 21c folder
3  unzip
4  click on setup

installation :- 
-----------------

https://docs.oracle.com/en/database/oracle/oracle-database/21/xeinw/installing-oracle-database-xe.html

 7-oct-25 

 Datatypes in oracle :- 
 ================

  => a datatype specifies 

  1 what type of the data allowed in a column
  2 amount of memory allocated for column 
  
			DATATYPES 

        CHAR	      NUMERIC	  DATE	  	BINARY

ASCII	UNICODE	      number(p)	  date		bfile	
number(p,s)	  timestamp	blob
char	 nchar
varchar2    nvarchar2
long	  nclob
clob

char(size) :- 
--------------

  => allows character data upto 2000 chars 
  => recommended for fixed length char columns 

  ex :-      NAME    CHAR(10)

              SACHIN - - - -           	10 bytes
                             wasted 

             RAVI - - - - - -	 10 bytes 
                            wasted
 
 =>  in char datatype extra bytes are wasted , so don't use char for variable length
       fields and use char for fixend length fields.

        ex :-             GENDER      CHAR(1)

                            M
                            F

                            STATE_CODE     CHAR(2)

                           AP
                          TG
                          MH 

	           COUNTRY_CODE     CHAR(3)

	            IND
	            USA

 VARCHAR2(size) :- 
----------------------------

  => allows character data upto 4000 chars
  => recommended for variable length char fields.

 ex :-         NAME   VARCHAR2(10)


                 SACHIN - - - -                 6 bytes
                                 released
                
                 RAVI  -  - - - - -                4 bytes 
                               released

 upto ver 6  it is varchar
 from 7 onwards varchar2

 LONG :- 
 -------------

  => allows character data upto 2GB

       ex :-   review   LONG

 CLOB :-    (character large object) 
 -----------
 
 => allows character data upto 4GB

      ex :-  review  CLOB 

 note :- 
 -----------

  => char/varchar2/long/clob  allows ascii chars (256) that includes 
       a-z,A-Z,0-9,special chars.
 
 => char/varchar2 datatype allows alphanumeric data.
 
  ex :-          panno     char(10)
                   vehno     char(10)
                   emailid   varchar2(20)
 
 nchar / nvarchar2 / nclob :-        ( n => national)
 =====================

 => allows unicode chars (65536) that includes all ascii chars and also chars
      belongs to different languages 

 => ascii char occupies 1 byte and unicode char occupies 2 bytes 

 Number(p) :- 
 ----------------

   => allows numeric data upto 38 digits 
   =>  allows numbers without decimal (integers)

   ex  :-     empid       Number(4)
    
                10
                100
                1000
                10000  => not allowed 

                 aadharno   Number(12)
                 phone        Number(10)
                 accno        Number(14)

 Number(p,s)  :- 
 ==============

 => allows numbers with decimal (float)

     p   =>  precision =>  total no of digits allowed 
     s   =>  scale       =>  no of digits allowed after decimal

      ex :-    salary    Number(7,2)

                  5000
                  5000.56
                50000.56
               500000.56   =>  not allowed 

                   5000.5678  =>  allowed =>  5000.57
                   5000.5637  =>  allowed =>  5000.56

                  savg        Number(5,2) 

                  balance   Number(11,4)

DATE :- 
-----------

  => allows date & time
  => time is optional , if not entered then oracle stores 12:00AM
  => default date format in oracle is DD-MON-YY / YYYY  
  => time format is hh:mi:ss

    ex :-   DOB      DATE

              10-OCT-05      => 10-OCT-2005
              15-MAR-98     => 15-MAR-2098
              15-MAR-1998 => 15-MAR-1998

 TIMESTAMP :- 
  -------------------

  => allows date,time and also milliseconds
      
         ex :-  T       TIMESTAMP 
 
                  07-OCT-25 15:41:20.123
                 --------------- ------------  -----
                       DATE       TIME      MS 

8-oct-25 

 Binary Types :- 
 ===========

 => binary types are used for storing multimedia objects like audio,video,images 
 => oracle supports two binary types 

 1 BFILE  (binary file )
 2 BLOB  (binary large object)

 => BFILE is called external lob because lob (audio,video,img)  is stored outside db 
      and db stores path.

 => BLOB is called internal lob because lob is stored inside db.

          ex :-     photo         BFILE
 
                     sign            BLOB


 creating tables in database :- 
 =======================

 syntax :-
 -----------

  CREATE TABLE <tabname>
  (
       colname    datatype(size) ,
       colname    datatype(size),
       -----------------------
  ) ;

 Rules :- 

 1  tabname should start with alphabet
 2  name should not contain spaces & special chars but allows _   $   #
 3  name can be upto 128 chars
 4  table can have max 1000 columns
 5  no of rows unlimited 

    tabname  :-        123emp       invalid
	              emp 123	invalid
	              emp*123	invalid
	              emp_123	valid

 Ex :- 

  => create table with following structure ?

      EMP
      empid	   ename     job    sal      hiredate      dept

    CREATE TABLE emp
    (
        empid    NUMBER(4) ,
        ename   VARCHAR2(10),
        job         VARCHAR2(10),
        sal         NUMBER(7,2) ,
       hiredate  DATE,
        dept       VARCHAR2(10)
    );

   above command created table structure / definition / metadata   that includes
   columns , datatype and size.

 DESC  :-        (DESCRIBE)
 -------------

 => command used to see the structure of the table

        syntax :-              DESC   <tabname>

        ex :-         

         SQL>DESC  emp

	 EMPID                 NUMBER(4)
	 ENAME                VARCHAR2(10)
 	JOB                       VARCHAR2(10)
 	SAL                        NUMBER(7,2)
 	HIREDATE             DATE
 	DEPT                     VARCHAR2(10)

 inserting data into table :- 
 ----------------------------------

 =>  " insert"  command is used to insert data into table.
 =>   insert command creates new row
 =>   we can insert 

 1  single row
 2  multiple rows 
    
 inserting single row :- 
 -------------------------------

         INSERT INTO <tabname>  VALUES(v1,v2,v3,-----------) ; 
 
Ex :- 
 
  SQL>INSERT INTO emp VALUES(100,'sachin','clerk',4000,'8-oct-25','hr');
  SQL>INSERT INTO emp VALUES(101,'arvind','manager',8000,sysdate,'sales');

inserting multiple rows :- 
-----------------------------------

 => we can execute insert command multiple times with different values by using
      variables prefixed with  "&". 

    SQL>INSERT INTO emp VALUES(&empid,&ename,&job,&sal,&hiredate,&dept);
Enter value for empid: 102
Enter value for ename: 'david'
Enter value for job: 'analyst'
Enter value for sal: 9000
Enter value for hiredate: '20-apr-20'
Enter value for dept: 'it'

old   1: INSERT INTO emp VALUES(&empid,&ename,&job,&sal,&hiredate,&dept)
new   1: INSERT INTO emp VALUES(102,'david','analyst',9000,'20-apr-20','it')

1 row created.

SQL> /   (to execute previous command)

Enter value for empid: 103
Enter value for ename: 'vijay'
Enter value for job: 'clerk'
Enter value for sal: 6000
Enter value for hiredate: '10-FEB-18'
Enter value for dept: 'sales'
old   1: INSERT INTO emp VALUES(&empid,&ename,&job,&sal,&hiredate,&dept)
new   1: INSERT INTO emp VALUES(103,'vijay','clerk',6000,'10-FEB-18','sales')

1 row created.

NOTE :- 

 => above insert commands inserted data into instance (ram) which is tempoary
      to save this data execute commit and after executing commit data is copied
      to db 
  
   SQL>COMMIT ;

=> in normal exit opeations are saved and in abnormal exit operations not saved 

        SQL> EXIT ;   => normal exit

        closing window  => abnormal exit

Inserting nulls :- 
-----------------------

 => a null means blank of empty
 => it is not equal to 0 or space
 => nulls are inserted when value is absent 
 => nulls can  be inserted in two wasy 

 method 1 :- 
 --------------

 SQL>INSERT INTO emp VALUES(105,'ravi','' , null,'22-JAN-23','hr');

 method 2 :- 
 ---------------

 SQL>INSERT INTO emp(empid,ename,hiredate,dept) VALUES(106,'satish',sysdate,'it');

       remaining two fileds filled with nulls

9-oct-25 

 Operators in ORACLE :- 
 ----------------------------------

 1   Arithmetic operators 	=> 	+	-	*	/ 
 2   Relational operators	=>	>    >=   <    <=    =     <>    !=
 3   Logical operators	=>	AND   OR   NOT
 4   Special operators	=>	BETWEEN
				IN
				LIKE
				IS
				ANY
				ALL
				EXISTS

   5  Set operators		=>	UNION
				UNION ALL
				INTERSECT
				MINUS

Displaying Data :- 
------------------------

 => "select"  command is used to display data from table.
 =>  we can display all rows and all columns
 => we can display specific rows and specific columns
    
  syntax :- 

    SELECT  col1,col2,col3,---   /  *   FROM tabname
  
  	SQL	=	ENGLISH			
	QUERIES  =	SENTENCES
	CLAUSES  = 	WORDS

                FROM clause    => specify tablename
                SELECT clause => specify column names
                *                         =>  all columns

  => display employee names and salaries ? 

      SELECT ename,sal  FROM emp ;

 => display employee names and jobs ?
 
    SELECT ename,job FROM emp ;

 => display names,jobs,salaries and hiredates ?

    SELECT ename,job,sal,hiredate FROM emp;

 => display all the data from emp ?

    SELECT * FROM emp ; 

WHERE clause :- 
------------------------

 => used to select specific row/rows from table 
 => where clause is always associated with condition
 
   SELECT  columns
   FROM tabname
   WHERE  condition  ;
 
condition :- 
---------------

        COLNAME   OP    VALUE

=> condition always returns TRUE / FALSE.
=> OP must be any relational operator like  >   >=   <    <=   =    <>   != 
=>  if cond = true then row is selected
=> if cond = false row is not selected 
 
Ex :- 

 => display employee details whose id = 103 ? 

      SELECT  *  FROM emp WHERE empid = 103 ; 

 => display employee details whose name is david ? 

      SELECT * FROM emp WHERE ename = 'david' ; 

 => employee details earning more than 10000 ? 

     SELECT * FROM emp WHERE sal > 10000 ; 

 => employee details joined after 2020  ?

     SELECT * FROM emp WHERE hiredate > 2020 ;   => ERROR

                                                       date             number

    note :-  when comparing both values type must be same

      SELECT * FROM emp WHERE hiredate > '31-DEC-2020' ;

  => employees joined before 2020 ? 

     SELECT * FROM emp WHERE hiredate < '01-JAN-2020' ; 

=> employees not working for hr dept ?

    SELECT * FROM emp WHERE dept  <> 'hr' ; 
   
 compound condition :- 
 -----------------------------

 => multiple conditions combined with  AND / OR  operators called 
      compound condition

       WHERE  cond1   AND   cond2	RESULT
	
	       T		T	T
	       T		F	F
	       F		T	F
	       F		F	F

      WHERE   cond1   OR   cond2	RESULT
	
	      T		T	T
	      T		F	T
	      F		T	T
	      F		F	F	

 Ex :- 

 => employees working as clerk,manager ? 

     SELECT * FROM emp WHERE job='clerk'  OR  job='manager'  ; 
 
 => employees whose id = 100,103,105 ? 

     SELECT * FROM emp WHERE empid=100 OR empid=103 OR empid=105 ;

 => employees working as clerk earning more than 5000 ? 
  
      SELECT * FROM emp WHERE job='clerk' AND sal > 5000 ; 

 => display sales dept manager details ? 

      SELECT * FROM emp WHERE  dept='sales'  AND  job='manager' ; 

 => employees earning more than 5000 and less than 10000 ? 

     SELECT * FROM emp WHERE sal > 5000  AND  sal < 10000 ; 

 => employees joined in 2020 year ?

     SELECT * 
     FROM emp
     WHERE hiredate >= '01-JAN-2020'
                   AND
                   hiredate <= '31-DEC-2020' ;

 => employees working as clerk,manager and earning more than 5000 ? 
 
     SELECT *
     FROM emp 
     WHERE job='clerk'  OR  job='manager'  AND  sal > 5000 ;
                   -------------         --------------------------------------------

   above query returns clerks earning less than 5000 because sal > 5000
   is applied only to manager but not to clerk because operator AND has
   got more priority than operator OR , to overcome this group the
   conditions by using  (   ) .

     SELECT *
     FROM emp 
     WHERE  ( job='clerk'  OR  job='manager' )  AND  sal > 5000 ;
                    -------------------------------------------           ----------------
 => 

CREATE TABLE student
    (
      sid  NUMBER(2),
       sname VARCHAR2(10),
       s1    NUMBER(3),
       s2    NUMBER(3),
       s3    NUMBER(3)
     );
 
  INSERT INTO student VALUES(1,'A',80,90,70);
  INSERT INTO student VALUES(2,'B',30,60,50);
  INSERT INTO student VALUES(3,'C',60,30,20);
  INSERT INTO student VALUES(4,'D',20,30,10);

 student
 sid	sname	s1	s2	s3
 1	A	80	90	70
 2	B	30	60	50
 3	C	60	30	20
 4	D	20	30	10

=> list of students who are passed ?

   SELECT * FROM student WHERE s1>=35 AND s2>=35  AND s3>=35 ; 

=> list of students who are failed ?

   SELECT * FROM student WHERE s1<35 OR  s2<35 OR s3<35  ;

 => list of students who are failed exactly in 1 subject ?

   SELECT * 
   FROM student
   WHERE  (s1<35 AND s2>=35 AND s3>=35)
                   OR
                   (s1>=35 AND s2<35 AND s3>=35)
                   OR
                   (s1>=35 AND s2>=35 AND s3<35 ) ;


 => list of students who are failed exactly in 2 subjects ?
  
 SELECT * 
   FROM student
   WHERE  (s1<35 AND s2<35 AND s3>=35)
                   OR
                   (s1<35 AND s2>=35 AND s3<35)
                   OR
                   (s1>=35 AND s2<35 AND s3<35 ) ;


 => list of students who are failed in all 3 subjects ?

   SELECT *
   FROM student
   WHERE s1<35 AND s2<35 AND s3<35 ; 
   
 IN operator :- 
 ------------------

  => use IN operator for list comparison
  => use IN operator for "=" comparison with multiple values 
  
       WHERE colname =  v1,v2,v3,---    =>  INVALID

       WHERE colname IN (v1,v2,v3,---)  =>  VALID
  
  => employees whose id = 100,103,105 ?

      SELECT *
      FROM emp 
      WHERE empid  IN (100,103,105) ; 
 
 => employees working as clerk,manager ?

     SELECT *
     FROM emp
     WHERE job IN ('clerk','manager') ; 

 => employees not working for dept hr,it ?

  SELECT *
  FROM emp
  WHERE dept NOT IN ('hr','it') ; 

BETWEEN operator :- 
-----------------------------

=> use between operator for range comparison

    ex :-  5000 to 10000
             2020 to 2025 

   WHERE colname BETWEEN v1 AND v2 

=> employees earning between 5000 and 10000 ?

    SELECT *
    FROM emp 
    WHERE sal BETWEEN 5000 AND 10000 ;   (sal >= 5000 AND sal <= 10000)

  => employees joined in 2020 year ?

  SELECT *
  FROM emp 
  WHERE hiredate BETWEEN '01-JAN-2020'  AND '31-DEC-2020' ; 

=> who are not joined in 2020 ?

   SELECT *
  FROM emp 
  WHERE hiredate NOT BETWEEN '01-JAN-2020'  AND '31-DEC-2020' ; 

  COL = V1
  OR
  COL = V2   ========================>    COL  IN (V1,V2,V3)
  OR
  COL = V3 

  COL >= V1
  AND              ========================>  COL BETWEEN V1 AND V2 
  COL <= V2
 
 => employees working as clerk,manager and earning between 5000 and 10000
      and not joined in 2020 and not working for dept hr,it ? 

    SELECT *
    FROM emp 
    WHERE job IN ('clerk','manager')
                   AND
                  sal BETWEEN 5000 AND 10000
                  AND
                  hiredate NOT BETWEEN '01-JAN-2020' AND '31-DEC-2020'
                  AND
                  dept NOT IN ('hr','it') ;


 => list of samsung,redmi,realme mobiles price between 10000 and 20000 ? 

  products
  prodid	pname	price	category	 brand

  SELECT *
  FROM products 
  WHERE  brand IN ('samsung','redmi','realme')
                 AND
                 price BETWEEN 10000 AND 20000
                 AND
                category='mobiles' ; 

 => list of male customers staying in hyd,blr,mum age between 20 and 40 ? 

  CUST
  cid	name	city	age	gender

  SELECT *
  FROM cust
  WHERE gender='M' 
                AND
                city IN ('hyd','blr','mum')
                AND
                age BETWEEN 20 AND 40 ; 

Question :- 

 SELECT *
 FROM emp 
 WHERE sal BETWEEN 10000 AND 5000 ; 

 a   ERROR
 b   returns rows 
 c   returns no rows
 d   none

 ans :-  c 

 WHERE sal BETWEEN 5000 AND 10000  (sal >= 5000 AND sal <=10000)

 WHERE sal BETWEEN 10000 AND 5000  (sal >= 10000 AND sal <=5000)

 note :- 

  => use between operator with lower and upper but not with upper and lower

 LIKE operator :- 
 --------------------

 => use LIKE operator for pattern comparison

         ex :-  name starts with 's'
                  name ends with 'd'
                  name contains 'a' 

         WHERE  colname  LIKE  'pattern' 

=> pattern contains alphabets,digits,special chars and also wildcard chars 

wildcard chars :- 
---------------------

  	%        =>  0 or many chars

  	_         =>  exactly 1 char

 => employees name starts with 's'  ? 

    SELECT *
    FROM emp
    WHERE  ename LIKE 's%' ; 

 => name ends with 'd'  ?

   SELECT *
   FROM emp 
   WHERE  ename LIKE '%d' ; 

=> name contains 'a' ? 

   SELECT *
   FROM emp 
   WHERE  ename LIKE '%a%' ; 

 => 'a' is the 4th char in their name ?

   SELECT *
   FROM emp 
   WHERE  ename LIKE '___a%' 

=> 'a' is the 4th char from last ?

   SELECT *
   FROM emp 
   WHERE  ename LIKE  '%a___'  ;

 => name contains 4 chars ? 

   SELECT *
   FROM emp 
   WHERE  ename LIKE  '____'  ; 

 11-oct-25 

 => employees joined in  october month ?      DD-MON-YY

    SELECT *
    FROM emp
    WHERE hiredate  LIKE  '%OCT%' ; 

    WHERE hiredate LIKE '___OCT___'  ;

 => employees joined in 2020 year ?

     SELECT *
    FROM emp 
    WHERE hiredate LIKE  '%20'  ; 

=> employees joined in 1st 9 days  of any month any year ?

          SELECT *
          FROM emp 
          WHERE hiredate LIKE  '0%' ; 
 
=>

 CUST
 cid	cname
 10	sachin_tendulkar
 11	virat%kohli
 12	mahendra_singh_dhoni

list of customers name contains "_"   ? 

 SELECT *
 FROM cust
 WHERE cname LIKE  '%_%'  ;
 
  above query returns all customer records because "_"  is not treated as search char
  and it is treated as wildcard char,  to overcome this use escape char.

 SELECT *
 FROM cust
 WHERE cname LIKE  '%\_%'    ESCAPE  '\'  ;

 => customers name contains  "%"  ? 

   SELECT *
   FROM cust
   WHERE cname LIKE  '%\%%'  ESCAPE '\' ; 

=> customers name contains 2 "_"   ? 

   SELECT *
   FROM cust
   WHERE cname LIKE  '%\_%\_%'   ESCAPE '\'  ; 
 
 IS  operator :- 
 -------------------

 => use IS operator for  NULL comparison
    
     WHERE  colname  IS NULL
     WHERE  colname IS NOT NULL

 => employees not earning salary ?

     SELECT *
     FROM emp 
     WHERE sal  IS   NULL  ; 

=> employees earning salary ?

     SELECT *
     FROM emp 
     WHERE sal  IS  NOT NULL  ; 

=> employees not assigned to any job ?

     SELECT *
     FROM emp 
     WHERE job IS NULL ;

summary :- 
-----------------

WHERE colname IN (v1,v2,v3,------)
WHERE colname BETWEEN v1 AND v2
WHERE colname LIKE 'pattern'
WHERE colname IS NULL

ALIAS :- 
------------

 =>  alias means another name
 =>  used to change column heading

        COLNAME / EXPR   AS   ALIAS

Ex :- 

  => display  ENAME   ANNUAL SAL  ?

      SELECT  ename,sal*12 AS annsal
      FROM emp ; 

      SELECT  ename,sal*12 AS  "ANNUAL SAL"
      FROM emp ; 
 
   => display  ENAME   EXPERIENCE  ? 
 
      SELECT   ename, hiredate, SYSDATE-HIREDATE AS EXPR
      FROM emp ;
   
    	 sachin    08-OCT-25 	3.63824074
	arvind     08-OCT-25 	3.01428241
	david      20-APR-20 	2000.63824
	vijay       10-FEB-18 		2800.63824

     SELECT   ename, hiredate, (SYSDATE-HIREDATE)/365  AS EXPR
      FROM emp ;

	sachin     08-OCT-25 	 .00996921
	arvind     08-OCT-25 	.008259735
	david      20-APR-20	 	5.48120209
	vijay      10-FEB-18 		7.67298291

      SELECT   ename, hiredate, ROUND((SYSDATE-HIREDATE)/365)  AS EXPR
      FROM emp ;

	sachin     08-OCT-25         0
	arvind     08-OCT-25          0
	david      20-APR-20          5
	vijay      10-FEB-18            8

 => display  ENAME   SAL    HRA    DA    TAX    TOTSAL   ? 
 
        HRA =  house rent allowance =  20% on sal
         DA   =  dearness allowance    =  30% on sal
         TAX  = 10% on sal
         TOTSAL = SAL + HRA + DA - TAX 

       SELECT  ename ,sal,
                       sal*0.2 as hra,
                       sal*0.3 as da,
                       sal*0.1 as tax,
                       sal + (sal*0.2) + (sal*0.3) - (sal*0.1) as totsal
       FROM emp ; 

                 ename    sal              hra           da             tax            totsal
	sachin	4000	800	1200	400	5600	

 =>  display  SNO   TOTAL    AVG   ? 

  STUDENT
  sno	sname	s1	s2	s3
  1	A	80	90	70
  2	B	60	50	40

   SELECT sno,s1+s2+s3 as total ,  (s1+s2+s3)/3 as avg 
   FROM student ; 

   1	240	80
   2	150	50

 13-oct-25 

 CASE statement :- 
 -------------------------

=> used to implement if-else in sql queries
=> using case statement we can return values based on condition
=> case statements are 2 types 
 
1 simple case
2 searched case

 simple case :- 
---------------------

=> use simple case when conditions based on "=" operator

  CASE   colname
  WHEN value1 THEN return value1
  WHEN value2 THEN return value2
  ----------------------------
 [ ELSE return value]
  END

 Ex :- 

 => display  ENAME     JOB  ? 

  IF  job=clerk  display  WORKER
       job=manager         BOSS
       others                    EXECUTIVE

   SELECT ename ,
                  case job
                  when 'clerk'  then 'worker'
                  when 'manager' then 'boss'
                  else 'executive'
                  end  as job
  FROM emp ; 

 => display  CID 	CNAME	GENDER  ?
		
		IF gender='M' display MALE
                                                    F  display FEMALE
  CUST
  cid	cname	gender
  10	A	M
  11	B	F

  SELECT cid,cname, 
                 CASE gender
                 WHEN 'M' THEN 'MALE'
                 WHEN 'F' THEN 'FEMALE'
                 END as gender
 FROM cust ; 
 
	10	A	MALE
	11	B	FEMALE

searched case :- 
----------------------

 => use searched case when conditions not based on "=" operator

 CASE
 WHEN cond1 THEN return value1
 WHEN cond2 THEN return value2
 ---------------------
 [ELSE return value]
 END

 Ex :- 

 => display  ENAME  SAL    SALRANGE ?

             if  sal<5000  display  LOSAL
                 sal>5000  display  HISAL
                 otherwise               AVGSAL

 SELECT  ename,sal,
                 CASE
                 WHEN sal<5000 THEN  'LOSAL'
                 WHEN sal>5000 THEN 'HISAL'
                 ELSE 'AVGSAL'
                 END  as salrange
 FROM emp 

 =>  display  SID TOTAL    AVG    RESULT ?

    if all subject marks >=35  result is pass
    otherwise                                       fail


  STUDENT
  sid	sname	s1	s2	s3
  1	A	80	90	70
  2	B	60	50	30

 SELECT  sid ,
                 s1+s2+s3 as total,
                 (s1+s2+s3)/3 as avg,
                 CASE
                 WHEN  s1>=35 AND s2>=35 AND s3>=35 THEN 'pass'
                 ELSE 'fail'
                 END as result
 FROM student ;

=================================================================
 
14-oct-25

ORDER BY clause :- 
================

=> ORDER BY clause is used to sort table data
=> using ORDER BY clause we can sort based on one or more columns
=> we can sort either in ascending or in descending order.

 SELECT columns / * 
 FROM tabname
 [WHERE cond]
 ORDER BY  colname  ASC / DESC  , colname ASC/DESC , colname ASC/DESC

 => default sort order is ASC 

		ASC		DESC

    NUMBERS	small - high	high - small
    CHAR		a - z		z - a
    DATE		old - new		new - old
  	 
 

Ex :- 

 => display employee list  name wise ascending order ?

    SELECT *
    FROM emp
    ORDER BY  ename  ASC ;

 => display employee list sal  
      highest paid employee should be displayed first ?

   SELECT *
   FROM emp 
   ORDER BY sal DESC ; 

 => arrange employee list hiredate  wise
      employee who joined first arrange first ? 

  SELECT *
  FROM emp 
  ORDER BY hiredate  ASC ; 
 
sorting based on multiple columns :-
-------------------------------------------------
 
 => arrange employee list dept wise asc and with in dept sal wise desc order  ?

   SELECT empno,ename,sal,deptno
   FROM emp
   ORDER BY  deptno ASC , sal DESC ; 

   1    A   3000   20				 5    E   6000  10		
   2    B   6000  30 				 3    C   4000  10
   3    C   4000  10    ==================> 	 4    D   5000  20	 
   4    D   5000  20				 1    A   3000   20	
   5    E   6000  10				 2    B   6000  30 
   6    F   3000  30				 6    F   3000  30				

=> arrange employee list dept wise asc and with in dept hiredate wise asc ?

 SELECT empno,ename,hiredate,deptno 
 FROM emp
 ORDER BY deptno ASC,hiredate ASC ; 

 => arrange student list avg wise desc 
      if avg is same then m wise desc 
      if m also same then p wise desc ?

   student
   sno	sname	m	p	c
    1	A	80	90	70
    2	B	60	50	70
    3	C	90	80	70
    4	D	90	70	80

   SELECT sno,sname,m,p,c,(m+p+c)/3 as avg
   FROM student
   ORDER BY  (m+p+c)/3  DESC,m DESC,p DESC ; 

    
    3	C	90	80	70	80
    4	D	90	70	80	80
    1	A	80	90	70	80
    2	B	60	50	70	60


     ORDER BY   avg  DESC   =>   valid
     WHERE  avg >= 70           =>   invalid

 note :- 

 => column alias cannot be used in WHERE clause because WHERE clause
      is executed before SELECT clause.

 => column alias can be used in ORDER BY because ORDER BY clause is 
      executed after SELECT clause.

 order of execution :-
 --------------------------

 FROM
 WHERE
 SELECT
 ORDER BY 

=> display employees working as clerk,manager
     arrange output sal wise desc order ?

     SELECT empno,ename,job,sal
     FROM emp 
     WHERE job IN ('CLERK','MANAGER')
     ORDER BY sal DESC ;

 FROM emp :- 
 -------------------

  1	A	CLERK		3000
  2	B	MANAGER	5000
  3	C	SALESMAN	2000
  4	D	CLERK		4000

WHERE job IN ('CLERK','MANAGER') :- 
-------------------------------------------------------

 1	A	CLERK		3000
 2	B	MANAGER	5000
 4	D	CLERK		4000

SELECT empno,ename,job,sal :- 
--------------------------------------------

 1	A	CLERK		3000
 2	B	MANAGER	5000
 4	D	CLERK		4000

ORDER BY sal DESC  :-
-----------------------------------

 2	B	MANAGER	5000
 4	D	CLERK		4000
 1	A	CLERK		3000
 
 => display employee details joined in 1981 year
      and arrange output name wise asc ? 

      SELECT empno,ename,hiredate
      FROM emp
      WHERE hiredate LIKE  '%81'  
      ORDER BY ename ASC ; 
 
 controlling NULLs :- 
 ----------------------------

  => In sorting by default nulls are treated  high.
  => In ascending order nulls arranged last
 =>  In descending order nulls arranged first
 =>  To control this use NULLS FIRST / LAST options

 Ex :- 

  => arrange employee list comm wise desc order but display nulls last ?

   SELECT empno,ename,sal,comm
   FROM emp 
   ORDER BY comm DESC NULLS LAST ; 

   EMPNO ENAME             SAL       COMM
---------- ---------- ---------- ----------
      7844 TURNER           1500          0
      7499 ALLEN            1600          300
      7521 WARD             1250        500
      7654 MARTIN           1250       1400
      7788 SCOTT            3000
      7839 KING             5000
      7876 ADAMS            1100
      7900 JAMES             950
      7902 FORD             3000
      7934 MILLER           1300
      7698 BLAKE            2850
      7566 JONES            2975
      7369 SMITH             800
      7782 CLARK            2450

  => arrange employee list comm wise asc display nulls first ?

    SELECT empno,ename,sal,comm
    FROM emp
    ORDER BY comm ASC NULLS FIRST ; 

  
     EMPNO 	ENAME             SAL       COMM
---------- 	---------- ---------- ----------
      7369 SMITH             800
      7782 CLARK            2450
      7902 FORD             3000
      7900 JAMES             950
      7876 ADAMS            1100
      7566 JONES            2975
      7698 BLAKE            2850
      7934 MILLER           1300
      7788 SCOTT            3000
      7839 KING             5000
      7844 TURNER           1500          0
      7499 ALLEN            1600        300
      7521 WARD             1250        500
      7654 MARTIN           1250       1400

15-oct-25 

 DISTINCT clause :- 
 ---------------------------

 => distinct clause eliminates duplicates from select stmt output 
 
      SELECT  DISTINCT  col1,col2,----
      FROM tabname
      [WHERE cond]
      [ORDER BY col ASC / DESC , ----]

Ex 1  :- 

  SELECT DISTINCT JOB FROM EMP ;

JOB
---------
CLERK
SALESMAN
ANALYST
MANAGER
PRESIDENT

Ex 2  :-  

  SELECT DISTINCT DEPTNO FROM EMP ;

    DEPTNO
----------
        30
        10
        20

 FETCH clause :- 
 ----------------------

  => FETCH clause is used to display TOP n rows from table

     SELECT  [DISTINCT]  col1,col2,---
     FROM tabname
     [WHERE cond]
     [ORDER BY col  ASC/DESC ,---]
     [OFFSET <n> ROWS ]  FETCH FIRST / NEXT  <n> ROW/ROWS ONLY ; 

Ex :- 

  => display first 5 rows from emp table ? 

       SELECT empno,ename,sal
       FROM emp
       FETCH FIRST 5 ROWS ONLY ; 

 => display 5th row ? 

       SELECT empno,ename,sal
       FROM emp
       OFFSET 4 ROWS FETCH  NEXT 1 ROW ONLY ; 
 
 => display 5th row to 10th row ?
 
       SELECT empno,ename,sal
       FROM emp
       OFFSET 4 ROWS FETCH NEXT 6 ROWS ONLY ; 

 => display top 5 highest paid employees ?

    SELECT empno,ename,sal
    FROM emp
    ORDER BY sal DESC
    FETCH FIRST 5 ROWS ONLY ;
 
 =>  display top 3 max salaries ? 

      SELECT DISTINCT sal
      FROM emp
      ORDER BY sal DESC
     FETCH FIRST 3 ROWS ONLY ;

       SAL
     ----------
      5000
      3000
      2975

  => display 5th max salary ? 
  
      SELECT DISTINCT sal
      FROM emp
      ORDER BY sal DESC
      OFFSET 4 ROWS FETCH NEXT 1 ROW ONLY ;

      SAL
   ----------
      2450

 => display top 3 employees based on experience ?

      SELECT empno,ename,hiredate
      FROM emp
      ORDER BY hiredate  ASC
      FETCH FIRST 3 ROWS ONLY ; 

 =>  latest 5 transactions of particular customer ? 

 TRANSACTIONS 
  trid	ttype	tdate		tamt	accno
  1	W	15-OCT-25 	2000	100
  2            W	15-OCT-25	1000	190
  3					122

  SELECT *
  FROM transactions 
  WHERE accno = 100
  ORDER BY tdate  DESC 
  FETCH FIRST 5 ROWS ONLY 

  summary :- 

  WHERE			=>  to select specific rows
  ORDER BY 		=>  to sort rows
  DISTINCT		=>  to eliminate duplicates
  FETCH 			=>  to select top n rows 
  
 ================================================================

  DML commands :-    (Data Manipulation Lang)
  ------------------------

  INSERT
  UPDATE
  DELETE
  MERGE 

 => all DML commands acts on table data.
 => DML commands acts on instance (ram).
 => to save the operation execute commit command
 => to cancel the operation rollback command

 UPDATE command :- 
 -----------------------------

  => command used to modify table data.
  => we can update all rows and specific rows
  => we can update single column or multiple columns 

  UPDATE tabname 
  SET colname = value , colname = value , ----------
  [WHERE cond] ; 

Ex :- 

 => update all employees comm with 500 ?

    UPDATE emp   SET  comm = 500  ;

 => update employees comm with 500 whose comm = null ?

    UPDATE emp SET comm = 500  WHERE comm IS NULL ; 
 
 => update employees comm with NULL whose comm <> null ? 

   UPDATE emp SET comm = NULL WHERE comm IS NOT NULL ; 

                NULL  assignment   =
                NULL  comparison   IS 

  => update sal with 1000 and comm with 500 whos empno = 7369 ?

      UPDATE emp
      SET  sal = 1000 , comm = 500
      WHERE empno = 7369 ; 

  => increment sal by 20% and comm by 10% those working as salesman
       and joined in 1981 year ? 

      UPDATE emp
      SET sal = sal + (sal*0.2)  , comm = comm + (comm*0.1)
      WHERE job='SALESMAN'
                    AND
                    hiredate  LIKE '%81'  ;

  => transfer employees from 10th dept to 20th dept ? 

      UPDATE emp
      SET deptno = 20 
      WHERE deptno = 10 ;

 => increase the price of samsung,redmi,realme mobiles by 10% ?

         products
         prodid	pname	price	category	brand
     
    UPDATE products 
    SET price = price + (price*0.1)
    WHERE  brand IN ('samsung','redmi','realme')
                   AND
                   category='mobiles' ; 
  
 =>  increment employee salaries as follows ?

        if deptno = 10  incr sal by 10%
                          20                    15%
                          30                    20%
                           others             5%

      UPDATE  emp 
      SET  sal = CASE  deptno
	       WHEN 10 THEN  sal + (sal*0.1)
                        WHEN 20 THEN  sal + (sal*0.15)
                        WHEN 30 THEN  sal + (sal*0.2)
                        ELSE sal+(sal*0.05)
                        END ;

  => swap employee jobs whose empno = 7369,7499  ?

     UPDATE emp 
     SET  job = CASE empno
                       WHEN 7369 THEN 'SALESMAN'
                       WHEN 7499 THEN 'CLERK'
                       END
   WHERE empno IN (7369,7499) ; 

 ===============================================================

 DELETE command :- 
 ----------------------------

  => command used to delete row/rows from table
  => it can delete all rows or specific rows
  
  syn :-      DELETE  FROM  <tabname>  [WHERE cond] 

Ex :- 

  => delete all rows from emp ? 

       DELETE FROM emp  ;

  => delete employees having more than 10 years experience ?

       DELETE 
       FROM emp 
       WHERE   (SYSDATE - hiredate)/365  >  10 ; 

 FLASHBACK :- 
 ---------------------

  => using flashback we can see the data that exists some time back.
  => a query that returns past data is called flashback query
  => using flashback we can recover data after commit.
  => we can flashback upto 15 mins
 
 syn :- 

  SELECT * 
  FROM tabname
  AS OF TIMESTAMP ( SYSDATE -  INTERVAL ) ;

Ex :- 

  => the following query returns 5 mins back data in emp table ?

  SELECT *
  FROM emp 
  AS OF TIMESTAMP (SYSDATE - INTERVAL '5' MINUTE) ;

 Recovering data after commit :- 
 ------------------------------------------

 step 1 :-   delete data 

  SQL>DELETE FROM emp ;

step 2 :-  save the operation

 SQL>COMMIT

 step 3 :- get the data that exists 5 mins back and insert that data into current emp table

  SQL>INSERT INTO emp
            SELECT *
            FROM emp 
             AS OF TIMESTAMP (SYSDATE - INTERVAL '5' MINUTE) ;

   data returned by query is inserted into current emp table

 17-oct-25

DDL command :-     (Data Definition Lang)
-----------------------

 CREATE
 ALTER
 DROP
 TRUNCATE 
 RENAME
 FLASHBACK
 PURGE

 => all DDL commands acts on table structure
 => all DDL commands are auto committed.

           DDL command =  DDL command + COMMIT

  scenario 1 :- 
 
create table a(a number(2));
insert into a values(10);
insert into a values(20);
insert into a values(30);
insert into a values(40);
insert into a values(50);
rollback ;

output :- create table  => saved
          inserts       => cancelled

scenario 2 :- 

create table a(a number(2));
insert into a values(10);
insert into a values(20);
insert into a values(30);
create table b(b number(2));
insert into b values(40);
insert into b values(50);
rollback ;

create table a  => saved
insert 10,20,30 => saved
create table b  => saved
insert 40,50    => cancelled

ALTER command :-
-----------------

 => command used to modify the table structure
 => using ALTER command we can

 1 add columns
 2 drop columns
 3 rename a column
 4 modify a column

Adding a column :-
-------------------------

 => add column gender to emp table ? 

  ALTER TABLE emp
      ADD (gender CHAR(1));

=> after adding by default the new column is filled with nulls , to insert data into 
  the new column use update command.

  UPDATE emp SET gender='m' WHERE empno=7369;

  UPDATE emp SET gender='f' WHERE empno = 7499;

 Droping column :- 
 -------------------------

 => drop column gender from emp table ?

  ALTER TABLE emp 
        DROP (gender) ;

 Renaming a column :- 
 -----------------------------

 => rename column comm to bonus ? 

  ALTER TABLE emp 
      RENAME COLUMN comm TO bonus ; 

  SELECT empno,ename,sal,comm as bonus
  FROM emp ;

 => diff b/w rename & alias ?

        rename			alias 

   1    permanent                     		tempoarary

   2    changes column name            	changes column heading in select stmt output
         in table

 Modifying a column :- 
 ----------------------

 1 incr/decr field size
 2 changing datatype

=> increase size of ename to 20 ?

  ALTER TABLE emp 
        MODIFY(ename VARCHAR2(20));

=> decrease size of ename to 10 ? 

 ALTER TABLE emp 
        MODIFY(ename VARCHAR2(10));

  ALTER TABLE emp 
        MODIFY(ename VARCHAR2(5));  => ERROR (some name contains more than 5 chars)

NOTE :- 

 1  column must be empty to decrease precision or scale of numeric field

  ALTER TABLE emp
    MODIFY (sal  NUMBER(6,2));  => error

 2 column must be empty to change datatype 

   ALTER TABLE emp
      MODIFY(empno VARCHAR2(10));  => error

 DROP command :- 
 ----------------

 => command used to drop table from database.
 => drops table structure with data.

  syn :- DROP TABLE <tabname>

  ex :-  DROP TABLE emp ; 
 
 => prior to 10g ver when table is dropped it is removed permanently and from 10g onwards
   when table is dropped it is moved to recyclebin.

 => to see the recyclebin execute the following command

  SQL>SHOW RECYCLEBIN ;

18-oct-25 

 FLASHBACK  :- 
 -------------------- 

  1  flashback data
  2  flashback table

 flashbacking data :- 
 --------------------

 step 1 :-   SQL>DELETE FROM emp ;

 step 2 :-   SQL>COMMIT;
 
 step 3 :-  SQL> INSERT INTO emp
                          SELECT *
                          FROM emp 
                          AS OF TIMESTAMP(SYSDATE - INTERVAL '2' MINUTE);

  flashbacking table :- 
  ---------------------------

   SQL>DROP TABLE emp ; 

  => before 10g when table is dropped then it is permanently deleted from db
  => from 10g when table is dropped then it is moved to recyclebin
 
    How to see the recyclebin 

   SQL>SHOW RECYCLEBIN 

   EMP              BIN$kODIJUI1Qo2wsHyyRXjqSA==$0  TABLE        2025-10-17:15:42:46

  => the following command introduced by oracle in 10g to restore table from recyclebin

          FLASHBACK TABLE <tabname> TO BEFORE DROP ;

  Ex :- SQL>FLASHBACK TABLE emp TO BEFORE DROP ; 

     after executing above command table is restored with columns and rows
     that exists before drop.
 
   PURGE command :- 
   ---------------------------

   => command used to delete table from recyclebin
   => once table deleted from recyclebin we cannot flashback the table
   
                 PURGE TABLE <tabname> ;

 Ex :-   SQL>PURGE TABLE emp ;

  DROP & PURGE :- 
  -------------------------

    SQL> DROP TABLE student PURGE ;

    above command drops students table and also delete the table from recyclebin

 How to empty recyclebin :- 
 ----------------------------------

 SQL>PURGE RECYCLEBIN ; 

TRUNCATE command :- 
---------------------------------

 => command deletes all the data from table but keeps structure
 => command will empty the table
 => command will release memory allocated for table

          TRUNCATE TABLE <tabname> 

  Ex :-  SQL>TRUNCATE TABLE emp ; 

  => when above command is executed oracle goes to memory and releases
        all the blocks allocated for table and when blocks are released then
        data stored in memory also deleted.

 Memory allocation in oracle :- 
 ----------------------------------------

   => when table is created oracle allocates memory for the table as follows
 
            segment   =  collection of extents => by default it is created with 1 extent
            extent = collection of 8 blocks 
           1 block = 8kb

    => differentiate between DROP & DELETE & TRUNCATE ? 
            
	DROP			DELETE & TRUNCATE

	drops structure with data          deletes only data but not structure

   => difference between DELETE & TRUNCATE ?
	
	DELETE				TRUNCATE

  1	DML				DDL

  2	can delete all rows			can delete only all rows
                and also specific rows		cannot delete specific rows

  3	where cond can be used		where cond  cannot be
	with delete			used with truncate

  4	opertation can be rolledback		operation cannot be rolledback

  5	after delete we can flashback		after truncate we cannot flashback

  6	deletes row-by-row			deletes all rows at a time

  7	slower				faster

  8	will not release memory		will release memory 

 RENAME :- 
 ----------------

  => command used to change tablename 

            RENAME  <oldname> TO <newname> ;
 
Ex :-   SQL>RENAME emp TO employees ; 

 ==============================================================
 
21-oct-25

 Built-in Functions in ORACLE :- 
 -------------------------------------------
 
 => a function accepts some input and performs some calculation and returns one value

  Types of functions :- 
  -------------------------

  1  single row functions 
  2  multi row functions / aggregate functions  / group functions 

 single row functions :- 
 ---------------------------------

  => these functions process one row at a time and returns one value

  1  character functions
  2  numeric functions
  3  date functions
  4  conversion functions
  5  special functions
  6  analytical functions / window functions 

 character functions :- 
 -----------------------------

 UPPER() :- 
 ---------------

 =>  converts string to uppercase.

               UPPER(arg)

                 arg =>  string          =>  'hello'
                             colname      =>  ename

 Ex :- 

     SELECT UPPER('hello')  FROM  DUAL ;    =>  HELLO

    what is DUAL ?

    DUAL is a dummy table provided by oracle used to print non db values.

  LOWER() :-
  ----------------

  => converts string to lowercase 

                     LOWER(arg)

 Ex :- 

    SELECT LOWER('HELLO') FROM DUAL ;   =>   hello

 => display  EMPNO   ENAME  SAL ?
      display names in lowercase ?

      SELECT  empno , LOWER(ename)  as ename, sal  FROM emp ;

 => convert names to lowercase in table ?

      UPDATE emp SET ename = LOWER(ename) ;
 
 => display employee details whose name is BLAKE  ?

      SELECT *
      FROM emp 
      WHERE ename = 'BLAKE' ;    => no rows 

      in oracle string comparision is case sensitive i.e. uppercase and lowercase
      strings are not same. To perform case insensitive comparison use 
      UPPER / LOWER functions.

      SELECT *
      FROM emp 
      WHERE UPPER(ename) = 'BLAKE' ; 
 
 INITCAP() :- 
 -----------------

  => converts initials into capitals 

                  INITCAP(arg) 

 Ex :- 

   SELECT INITCAP('sachin tendulkar')  FROM DUAL ;     =>  Sachin Tendulkar

 LENGTH() :- 
 ----------------

  => returns string length i.e. no of chars .

                  LENGTH(arg) 

 Ex :- 

   SELECT LENGTH('HELLO WELCOME') FROM DUAL ;    => 13 

 => display ENAME   LENGTH  ?

    SELECT    ename , LENGTH(ename) as LEN    FROM emp ; 

      smith	   5
      allen      5
      ward      4
 
 => display employee list name contains 4 chars ?

        SELECT    *
        FROM emp 
        WHERE ename LIKE  '____'  ;
  
        SELECT    *
        FROM emp 
        WHERE LENGTH(ename) = 4 ; 

 => employees name contains more than 4 chars ?

        SELECT    *
        FROM emp 
        WHERE LENGTH(ename) > 4 ; 

  => arrange employee list based on length of ename ?

      SELECT empno,ename,sal,LENGTH(ename) as len
      FROM emp
      ORDER BY LENGTH(ename)  ASC 

 SUBSTR() :- 
 -------------------

 => returns part of the string.

                   SUBSTR(string,start,[no of chars])

  Ex :- 

   SELECT SUBSTR('hello welcome',1,5)  FROM DUAL ;    =>  hello
   SELECT SUBSTR('hello welcome',7,5)  FROM DUAL ;    =>  welco
   SELECT SUBSTR('hello welcome',10,3) FROM DUAL ;   =>  com
   SELECT SUBSTR('hello welcome',10)  FROM DUAL ;      =>  come
   SELECT SUBSTR('hello welcome',7)  FROM DUAL ;        =>  welcome
   
   SELECT SUBSTR('hello welcome', -7,5)  FROM DUAL;  =>   welco
   SELECT SUBSTR('hello welcome', -4)  FROM DUAL;     =>   come
   SELECT SUBSTR('hello welcome', -10,5)  FROM DUAL; =>  lo we
 
 => employees name starts with 's' ?

       WHERE ename LIKE  's%'

     SELECT *
     FROM emp 
     WHERE  SUBSTR(ename,1,1) = 's' ; 

 => name ends with 's' ? 

    WHERE ename LIKE  '%s' 
 
     SELECT *
     FROM emp 
     WHERE  SUBSTR(ename,-1,1) = 's' ; 

 => employees name starting and ending with same char ?

 
     WHERE   ename LIKE 'a%a'
                     OR
                     ename LIKE 'b%b'
                     
   SELECT *
   FROM emp 
   WHERE  SUBSTR(ename,1,1)  =   SUBSTR(ename,-1,1) ; 
 
=>  generate emailids for employees ? 
 
      empno	ename		emailid
      7369		smith		smi736@tcs.com
      7499		allen		all749@tcs.com

   SELECT  empno,ename,
                   SUBSTR(ename,1,3) || SUBSTR(empno,1,3)||'@tcs.com' as emailid
   FROM emp ; 

 => store emailids in db ?

    STEP  1  :- add emailid column to emp table

     ALTER TABLE emp
              ADD (emailid  VARCHAR2(20));

   STEP 2 :-   update the column with emailids

    UPDATE emp 
    SET emailid =   SUBSTR(ename,1,3) || SUBSTR(empno,1,3)||'@tcs.com' ;

 INSTR() :- 
 ---------------

 =>  returns position of a character in a string.

                  INSTR(string,char,[start,occurance])

Ex :- 

    SELECT INSTR('HELLO WELCOME','O') FROM DUAL;	=>   5
    SELECT INSTR('HELLO WELCOME','K') FROM DUAL ;	=>   0

    SELECT INSTR('HELLO WELCOME','O',1,2) FROM DUAL ;   => 11
    SELECT INSTR('HELLO WELCOME','E',7,2) FROM DUAL ;   =>  13
  
   SELECT INSTR('HELLO WELCOME','E',-1,3) FROM DUAL ;    =>  2

   SELECT INSTR('HELLO WELCOME','E',-7,2) FROM DUAL ;    => 0   


 => display employees name contains 'a'  without using LIKE operator ?

     SELECT *
     FROM emp
     WHERE  INSTR(ename , 'a') <>  0  ; 
 
 scenario :- 
 -----------------

 CUST
 cid	cname
 10	sachin tendulkar
 11	virat kohli
 
 => display  CID	FNAME	   LNAME   ? 

        SUBSTR(string,start, [no of chars ])

        INSTR(string,char,[start,occurance])
 

       FNAME  =  SUBSTR(cname , 1 , INSTR(cname,' ')-1)
       LNAME   =  SUBSTR(cname, INSTR(cname,' ')+1 )

      SELECT  cid  ,
                      SUBSTR(cname,1,INSTR(cname,' ')-1) as fname,
                      SUBSTR(cname,INSTR(cname,' ')+1) as lname
     FROM cust ;

=>

   CUST
   cid	cname
   10	sachin ramesh tendulkar
   11	mahendra singh dhoni 

   display  CID	FNAME	   MNAME	     LNAME  ?

    FNAME = SUBSTR(cname , 1 , INSTR(cname,' ')-1)

    LNAME  = SUBSTR(cname, INSTR(cname,' ',1,2)+1)

    MNAME  = SUBSTR(cname,INSTR(cname,' ')+1 , INSTR(cname,' ',1,2)-INSTR(cname,' ' )-1) 

  SELECT  cid ,
                    SUBSTR(cname , 1 , INSTR(cname,' ')-1)  as fname ,
                    SUBSTR(cname,INSTR(cname,' ')+1 , INSTR(cname,' ',1,2)-INSTR(cname,' ')-1)  as mname,
                    SUBSTR(cname, INSTR(cname,' ',1,2)+1) as lname
  FROM cust ; 
            
  LPAD & RPAD :- 
  -----------------------

  => both functions used to fill string with a character 

             LPAD(string,length,char)     =>  fills on left side
             RPAD(string,length,char)     =>  fills on right side

  Ex :- 

      LPAD('HELLO',10,'*')	=>	*****HELLO
      RPAD('HELLO',10,'*')	=>	HELLO*****
      RPAD('*',10,'*')		=>	**********

  => display   ENAME     SAL   ?
                                        *** 
		       ****
 
     SELECT ename, RPAD('*',LENGTH(sal) , '*') as sal  FROM emp ; 
                    
 => 

  accounts
  accno		actype	bal
  123456789234	s	10000

  your a/c no XXXX9234  debited -----? 

 method 1      LPAD(SUBSTR(accno,-4,4) , 8 ,'X')
                                ----------------------------
	                 9234

 method 2       LPAD('X',4'X')||SUBSTR(accno,-4,4)
                          
                            XXXX          9234

  =>

   credit_cards
   card_no			exp_dt	cvv	pin
  1234567891234567


  output :- 12xxxx567

   SUBSTR(card_no , 1,2)||RPAD('x',4,'x')||SUBSTR(card_no,-3,3) 

 LTRIM,RTRIM,TRIM :- 
 -------------------------------
 
 => used to remove spaces and unwanted chars 


      LTRIM(string , [char])         =>   removes on left side
      RTRIM(string,[char])          =>   removes on right side
      TRIM(string)                      =>   removes both sides 

 Ex :- 

      LTRIM('     HELLO    ')	=>	'HELLO    '
      RTRIM('    HELLO    ')         =>             '       HELLO'
      TRIM('       HELLO   ')          =>            'HELLO'

      LTRIM('@@@HELLO@@@' , '@')	=>	HELLO@@@
      RTRIM('@@@HELLO@@@' , '@')    =>	@@@HELLO

      TRIM(BOTH '@' FROM  '@@@HELLO@@@')  => HELLO

  scenario :- 
  ---------------
 
 CREATE TABLE STUDENT
     (
      SID  NUMBER(2),
     SNAME CHAR(10)
     );

SQL> INSERT INTO STUDENT VALUES(10,'sachin');

SQL> INSERT INTO STUDENT VALUES(11,'nitin');

SQL> SELECT * fROM STUDENT ;

       SID SNAME
---------- ----------
        10 sachin
        11 nitin

 employees name ends with  'n' ? 

SQL> SELECT * FROM STUDENT WHERE SNAME LIKE '%n' ;

no rows selected

note :-  sname datatype is char  , so names are not ended with 'n' and ended with space
use RTRIM function to remove spaces on right side.

SQL> SELECT * FROM STUDENT WHERE RTRIM(SNAME) LIKE '%n' ;

       SID SNAME
---------- ----------
        10 sachin
        11 nitin
 
23-oct-25 

 REPLACE() :- 
 --------------------

  => used to replace one string with another string.

                 REPLACE(str1,str2,str3)

  =>  in str1 ,  str2   replaced with str3 
  
 Ex :-  

    REPLACE('HELLO','ELL','ABC')			=>	HABCO
    REPLACE('HELLO','L','ABC')			=>	HEABCABCO
    REPLACE( '@@@HE@@@L@@LO@@@@' , '@','')   	=>   	HELLO
    REPLACE('HELLO','ELO','ABC')			=>	HELLO

  => in hiredate column replace 'SEP' with 'OCT'   ? 

    UPDATE EMP SET HIREDATE = REPLACE(HIREDATE,'SEP','OCT');

  => employees name contains exactly 1 'a'  ? 

      SELECT * FROM emp WHERE ename LIKE  '%a%'  ;

     above query returns names contains 1 'a' and also 2 'a'

     SELECT * 
     FROM emp
    WHERE LENGTH(ename) -   LENGTH(REPLACE(ename,'a','')) =  1 ;
 

   ex :-  blake      LENGTH(ename) = 5
                           LENGTH(REPLACE(ename,'a','')) = 4 

  TRANSLATE() :- 
  ------------------------

   =>  used to translate one char to another char
 
                   TRANSLATE(str1,str2,str3)
 
Ex :-  

        TRANSLATE('HELLO','ELO','ABC')		=>      HABBC

		E  =>  A
                                  L  =>  B
                                 O  =>  C

       TRANSLATE('HELLO','ELO','')		=>     NULL

scenario :- 
-----------------

  => translate function can be used to encrypt data i.e. converting plain text to cipher text 

 Ex :- 

    =>  display ENAME   SAL  ?   encrypt salaries ?

         SELECT  ename  ,
                         TRANSLATE(sal , '0123456789' , '$Tb*R@j#^%') as sal 
         FROM emp ;

          jones   2975	    b%#@

=>   remove all special chars from  '@#HE$%LL^*O!*' ? 


SELECT  REPLACE( TRANSLATE('@#HE$%LL^*O!*' , '@#$%^*!' ,'*******')  , '*' , '')   FROM DUAL ;
                       -------------------------------------------------------------------------
                                     	**HE**LL**O**
  
   o/p :- HELLO

 summary :- 

  UPPER
  LOWER
  INITCAP
 LENGTH
 SUBSTR
 INSTR
 LPAD
 RPAD
 LTRIM
 RTIRM
TRIM
REPLACE
TRANSLATE

Numeric Functions :- 
------------------------------

 MOD() :- 
 ------------

 =>  returns remainder

              MOD(num1,num2) 

  Ex :- 

      MOD(10,5)		=>	0

 => display employees earning multiples of 100 ?

     SELECT *
     FROM emp 
     WHERE MOD(sal,100) = 0 ; 

 Rounding numbers :- 
 ----------------------------

  ROUND
  TRUNC
  CEIL
  FLOOR

        38.567894	=>	38
			39
			38.56
			38.5678
 
 ROUND functions :- 
 --------------------------

 => function used to round number to integer or to decimal places 
 => round function acts according to average
 
          ROUND( number , [decimal places]) 
 
Ex :-  

   ROUND(38.5678)		=>	39

   38----------------------------------38.5-----------------------------------------39
                          

          number >= avg   =>  rounded to highest
          number < avg      => rounded to lowest 

   ROUND(38.4678)		=>	38

   ROUND(38.5678,1)	=>	38.6

   ROUND(38.5478,1)	=>	38.5

   ROUND(38.5678,2)	=>	38.57

   ROUND(38.5672,3)	=>	38.567	

   ROUND(386 , -1)		=>	390

     
   380-------------------------------385--------------------------390


  ROUND(386,-2)		=>	400

  300---------------------------------350----------------------------------400

  ROUND(386,-3)		=>	0

   0-----------------------------------500-----------------------------------1000

Ex :- 

 SELECT ROUND(4567,-1) , ROUND(4567,-2) , ROUND(4567,-3) FROM DUAL ;

  o/p :-             4570           4600           5000

=> round all employee salaries to hundreds in table ? 

     UPDATE emp SET sal = ROUND(sal, -2) ;

 => display  ENAME  EXPERIENCE in years 
      round experience to integer ?

     SELECT ename, ROUND((SYSDATE - hiredate) / 365)  as exprr    FROM emp  ;
    
 TRUNC :- 
 ----------------

 =>  rounds number always to lowest 

                    TRUNC(number , [decimal places]) 
 
Ex :- 
 
	TRUNC(38.9567)		=>	38
                 TRUNC(38.5678,2)		=>	38.56
                 TRUNC(386,-2)		=>	300
	TRUNC(999,-3)		=>	0
        
24-oct-25 

  CEIL() :- 
  -------------

  => rounds number always to highest 

                 CEIL(number)

  Ex :- 

	   CEIL(3.1)		=>	4
   
 
FLOOR() :- 
----------------

 => rounds number always to lowest 

                     FLOOR(number) 

 Ex :-              FLOOR(3.9)		=>	3

             
DATE functions :- 
------------------------

sysdate + 10	=>	adds 10 days to sysdate
sysdate - 10	=>	subtracts 10 days from sysdate
sysdate - hiredate	=>	returns difference in days 
sysdate + hiredate	=>	invalid

 ROUND & TRUNC :- 
 ----------------------------

  => these two functions can also be used to round dates 
  => dates can be rounded to year / month /day 

     Ex :- 
 
	ROUND(SYSDATE,'YEAR')		=>	01-JAN-26 


 	01-JAN-25-----------------------------JUNE--------------------------------01-JAN-26 


                 ROUND(SYSDATE,'MONTH')		=>	01-NOV-25


	01-OCT-25------------------------------15th---------------------------------------01-NOV-25


	ROUND(SYSDATE,'DAY')		=>	26-OCT-25

	
	19-OCT-25-----------------------------------THU--------------------------------------26-OCT-25


                 ROUND(SYSDATE)			=>	

	24-OCT-25----------------------------------12PM---------------------------------25-OCT-25

    
                 TRUNC(SYSDATE,'YEAR')		=>	 01-JAN-25 

                 TRUNC(SYSDATE,'MONTH')		=>	01-OCT-25 

                 TRUNC(SYSDATE,'DAY')		=>	19-OCT-25 

                  TRUNC(SYSDATE)			=>	24-OCT-25 

 scenario :- 

   INSERT INTO emp(empno,ename,job,sal,hiredate)
                                VALUES(110,'rahul','clerk',2000,sysdate) ; 
 
    INSERT INTO emp(empno,ename,job,sal,hiredate)
                                VALUES(111,'kumar','clerk',2000,'24-OCT-25');

   => list of employees joined today  ?
 
       SELECT *
       FROM emp 
       WHERE hiredate  =  SYSDATE ;    =>  NO ROWS 

               24-OCT-2025 02:49:31   =   24-OCT-25 2:57:20
               24-OCT-2025 12:00:00

     NOTE :-   "="  comparison with  SYSDATE  always fails  because  oracle not only
     compares dates but also compares time ,  To overcome this problem use TRUNC function

       SELECT *
       FROM emp 
       WHERE TRUNC(hiredate)  =  TRUNC(SYSDATE) ;

                     24-OCT-25 12:00:00  =  24-OCT-25 12:00:00


 EXTRACT() :- 
-------------------------

  => used to extract year/month/day/hour/minute from date

   Ex :- 

   EXTRACT(YEAR FROM SYSDATE) 	=>	2025
   EXTRACT(MONTH FROM SYSDATE) 	=>	10
   EXTRACT(DAY FROM SYSDATE) 	=>	24

 => employees joined in 1980 ?  

   WHERE hiredate BETWEEN '01-JAN-1980' AND '31-DEC-1980'

   WHERE hiredate LIKE  '%80' 
 
   SELECT *
   FROM emp 
   WHERE  EXTRACT(year FROM hiredate) = 1980 ; 

   => employees joined in 1980,1983,1985 ?

   SELECT *
   FROM emp 
   WHERE EXTRACT(YEAR FROM hiredate)  IN (1980,1983,1985) ; 

 => employees joined in leap year ?

       SELECT *
       FROM emp 
       WHERE  MOD(EXTRACT(year FROM hiredate),4) = 0 ;

 => employees joined in jan,apr,dec months ?

     SELECT *
     FROM emp 
     WHERE EXTRACT(month FROM hiredate)  IN (1,4,12) ; 

 ADD_MONTHS :- 
 -------------------------

 => used to add / subtract   months   to/from a date 

                   ADD_MONTHS(DATE , NUMBER)

 Ex :- 

           ADD_MONTHS(SYSDATE,2)	=>	24-DEC-25
           ADD_MONTHS(SYSDATE,-2)	=>	24-AUG-25 

  scenario :- 
  ---------------

  GOLD_RATES
  DATEID		RATE
  01-JAN-20	?
  02-JAN-20	?
  

  24-OCT-25	? 

 => display today's   gold rate ?

     SELECT * 
     FROM GOLD_RATES
     WHERE  TRUNC(DATEID) =  TRUNC(SYSDATE) ;

 => display yeasterday's gold rate ?

    SELECT * 
     FROM GOLD_RATES
     WHERE  TRUNC(DATEID) =  TRUNC(SYSDATE-1) ;
    
 => display last month same day gold rate ?
  
    SELECT * 
     FROM GOLD_RATES
     WHERE  TRUNC(DATEID) =    TRUNC(ADD_MONTHS(SYSDATE,-1)) ;
     
 => display last year same day gold rate ?

     SELECT * 
     FROM GOLD_RATES
     WHERE  TRUNC(DATEID) =  TRUNC(ADD_MONTHS(SYSDATE,-12)) ;

 => display last 1 month gold rates ?

     SELECT * 
     FROM GOLD_RATES
     WHERE  TRUNC(DATEID)  BETWEEN    TRUNC(ADD_MONTHS(SYSDATE,-1))  AND  TRUNC(SYSDATE)

    WHERE TRUNC(DATEID)  >=    TRUNC(ADD_MONTHS(SYSDATE,-1)) 			
			       ------------------------------------------------------
				24-SEP-25

25-oct-25 

  MONTHS_BETWEEN() :- 
  ----------------------------------

  => returns no of  months between two dates 

               MONTHS_BETWEEN(date1,date2)

  Ex :- 

    MONTHS_BETWEEN(sysdate,'25-OCT-24')	=>	12

 Ex :- 

   => display  ENAME    EXPERIENCE  in years ?

        SELECT  ename , MONTHS_BETWEEN(sysdate , hiredate)/12  as expr
        FROM emp ;  

  => display experience in months ?

       SELECT  ename , MONTHS_BETWEEN(sysdate , hiredate)   as expr  FROM emp ;  

       	 smith       538.277537
	 allen        536.180762

     SELECT  ename , FLOOR(MONTHS_BETWEEN(sysdate , hiredate))   as expr  FROM emp 
   
	smith             538
	allen              536

    => display  ENAME    EXPERIENCE  ?
                                        M years N months 

       experience = 40 months =  3 years 4 months 

       years =  months / 12 =  FLOOR(40/12 ) = 3 

        months = MOD(months,12) = MOD(40,12) = 4 
 
     SELECT  ename , hiredate,
                     FLOOR(MONTHS_BETWEEN(sysdate,hiredate)/12)  as years,
                     MOD(FLOOR(MONTHS_BETWEEN(sysdate,hiredate)),12) as months
     FROM emp ;

  Conversion functions :- 
 -----------------------------------

 => these functions are used to convert one datatype to another datatype
  => the following functions provided by oracle for conversion

        1   TO_CHAR     =>  converts date / number to char type  
        2   TO_DATE      =>  converts string to date
        3   TO_NUMBER => converts string to number

 converting date to char :- 
 ---------------------------------

  =>  dates  converted to char type to display dates in different formats.

                TO_CHAR(date , 'format')

 Ex :- 

Formats :-               TO_CHAR(SYSDATE,'format')
-----------------
	
		yyyy			2025
		yy			25
		year			twenty twenty-five
		
		mm			10
		mon			oct
		month			october

		ddd			298 (day of the year  1-365)
		dd			25   (day of the month 1-31)
		d			7     (day of the week 1-7)					
		dy			sat
		day			saturday

		hh			hour
		hh24			24 hrs format
		mi			minutes
		ss			seconds
		AM/PM			AM time OR PM time			

		Q			quarter  (1-4)

					jan - mar		1
					apr -jun		2
				 	jul-sep		3				
					oct-dec		4

 Ex :- 

1  SELECT TO_CHAR(SYSDATE, 'yyyy yy year')  FROM DUAL  ;	 

 o/p :- 2025 25 twenty twenty-five

 2   SELECT TO_CHAR(SYSDATE, 'mm  mon  month')  FROM DUAL  ;

  o/p :- 10  oct  october

 3 SELECT TO_CHAR(SYSDATE, 'ddd dd d dy day')  FROM DUAL  ;
 
   298 25 7 sat saturday
 
 4    SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS AM') FROM DUAL ;

       25/10/2025 03:14:18 PM

5  SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS AM') FROM DUAL ;

    25/10/2025 15:15:05 PM

 => display  ename    day   ? 

     SELECT  ename , hiredate,TO_CHAR(hiredate,'day') as day FROM emp ; 

 => display  ENAME   HIREDATE  ?
      display hiredates  in   mm/dd/yyyy  ?
      display day of the week also ?

   SELECT  ename, TO_CHAR(hiredate,'mm/dd/yyyy  day') as hiredate FROM emp ;
 

 => display employees joined on sunday ?

    SELECT *
    FROM emp 
    WHERE TO_CHAR(hiredate,'dy') = 'sun' ;
 
 => employees joined in 2nd quarter of 1981 year ?

     SELECT *
     FROM emp 
     WHERE TO_CHAR(hiredate,'yyyy') =  1981
                    AND
                   TO_CHAR(hiredate,'q') = 2 ; 

    converting number to char type :- 
    ---------------------------------------------

  => numbers converted to char type to display numbers in differnet formats 

                        TO_CHAR(number , 'format')
 
 
 formats :- 
 ------------

  	9		represents a  digit
                 0		represents a digit
	G		thousand seperator
	D		decimal seperator
	L		currency symbol
	C		currency 

 Ex :- 

         TO_CHAR(1234, '99999')	=>	1234
         TO_CHAR(1234,'999999')	=>	1234
         TO_CHAR(1234,'00000')		=>	 01234
         TO_CHAR(1234,'000000')	=>	 001234
          TO_CHAR(1234,'9G999')	=>	 1,234
          TO_CHAR(500000,'9G99G999') 	=>	 5,00,000
          TO_CHAR(5000,'9G999D99')	=>	 5,000.00
          TO_CHAR(5000,'L9G999')	=>	 $5,000
           TO_CHAR(5000,'C9G999')	=>	 USD5,000

  => display  ENAME  SAL  ?

       display salaries with thousand seperator and currency symbol ?

      SELECT  ename , TO_CHAR(sal , 'C99G999D99') as sal FROM emp ; 

 => how to change currency ? 

   SQL> ALTER SESSION SET NLS_TERRITORY = 'INDIA' ;

   display  ENAME  SAL  ?  display salaries with indian currency ?

    SELECT  ename , TO_CHAR(sal , 'C99G999D99') as sal FROM emp ; 

                NLS => National Language Specification
 
27-oct-25 

 Converting  Date string to Date :- 
 -------------------------------------------
 
      Date string  =>    '27-OCT-2025'
                                  '10/27/2025'
                                  '2025-10-27'

             TO_DATE(date string , 'format')

 Ex :- 

   SQL> SELECT  sysdate + 10  FROM dual ;    =>  06-NOV-25

  SQL> SELECT  '01-NOV-25' + 100 FROM dual ;   => ERROR

    number + number   => valid
    date  + number       =>  valid
    date string + number      => invalid

  SQL> SELECT  TO_DATE('01-NOV-25' ,'DD-MON-YY')     + 100 FROM dual ;  

             o/p :- 9-feb-26 

 => add 50 days to '2026-01-01'  

     SQL>SELECT  TO_DATE('2026-01-01','YYYY-MM-DD') + 50  FROM DUAL ; 

     o/p :- 20-FEB-26 

=> waq  to display on which day india got independence ?

      SELECT 
            TO_CHAR( TO_DATE('15-AUG-1947' ,'DD-MON-YYYY'),'DAY')
     FROM DUAL ;

    o/p ;-  FRIDAY 

 Converting numeric string to Number :- 
 ------------------------------------------------------

            numeric string =>    '1234'
                                            '$1234'
                                            '$1,234'

               TO_NUMBER(numeric string , 'format')

 Ex :- 

  SQL>SELECT  1000 + 5000 FROM DUAL  ;    =>  6000

  SQL>SELECT  1000 + '5,000' FROM DUAL  ;  => ERROR

  SQL>SELECT  1000 + TO_NUMBER('5,000' , '9G999') FROM DUAL  ;  => 6000

 => calculate  '$5,000' +  'USD4,000"   ? 

  SQL>SELECT  TO_NUMBER( '$5,000' , 'L9G999') + 
                           TO_NUMBER( 'USD4,000' , 'C9G999')
           FROM DUAL ; 

                 o/p :-  9000

 
     	input			output		function
	
	5000			$5,000		TO_CHAR
	$5,000			5000		TO_NUMBER

	dd-mon-yy		mm/dd/yyyyy	TO_CHAR
	mm/dd/yyyy		dd-mon-yy	TO_DATE						
 
	default			other formats	TO_CHAR
	other			default		TO_DATE
 
 28-oct-25 

 Special Functions :- 
 -----------------------------
 
 NVL() :- 
 ----------

 =>  used to convert null values 

                          NVL(arg1,arg2) 

             if arg1 = null  returns arg2
             if arg1 <> null returns arg1 only 
   
Ex :- 

        NVL(100,200)		=>	100
        NVL(NULL,200)	=>	 200

 => display   ENAME  SAL   COMM   ?
      if comm = null display 0 ?

      SELECT  ename,sal,NVL(comm,0) as comm FROM emp ;

 => display ENAME  SAL  COMM  ?
      if comm = null display  N/A ?

      SELECT  ename,sal,NVL(comm,'N/A') as comm FROM emp ;  => error

      SELECT  ename,sal,NVL(TO_CHAR(comm),'N/A') as comm FROM emp ; 
   
  => display  ENAME   SAL   COMM   TOTSAL   ? 

                       TOTSAL = SAL + COMM 

       SELECT  ename,sal,comm , sal + comm as totsal FROM emp ;

      	jones             2975	  	 null
	martin           1250       1400       2650
	blake             2850		 null
	clark              2450		 null

      SELECT  ename,sal,comm , sal + NVL(comm,0) as totsal FROM emp ;

	jones             2975	  	 2975
	martin           1250       1400      2650
	blake             2850		2850
	clark              2450		2450

 ASCII() :- 
 -------------
 
 => returns ascii value of a given char

         ASCII(char) 

 Ex :- 

     ASCII('A')    =>  65 

 CHR() :- 
 ---------

  => returns character for given ascii value

            CHR(65)   =>  A 

Ex :- 
 
CUST
 cid	name	hno	street	city	state	pin
 10	A	100	ampt	hyd	tg	500036

output :-

 name
 hno
 street
 city
 state - pin 

 SELECT   name||CHR(10)||
                  hno||CHR(10)||
                  street||CHR(10)||
                  city||CHR(10)||
                  state||'-'||pin
 FROM cust
 WHERE cid = 10  ;
              
 How to implement loop in SQL :- 
 ---------------------------------------------

  SELECT  level 			 FOR(level=1 ; level<=10;level++)
  FROM DUAL                                   =>     {
  CONNECT BY level <= 10 ;                              print level ;
                                                                   }
   level = 1 ;
   while(level<=10)
   {
       print level ;
       level = level + 1
   }

 => level is system variable i.e. declared by oracle.
 => level is initialized with 1 
 => by default level is incremented by 1 

=> waq to print numbers from 1 to 100 ?

      SELECT LEVEL
      FROM DUAL
     CONNECT BY LEVEL <= 100 ; 

 => waq to print even nos upto 20 ?
 
      SELECT LEVEL
      FROM DUAL
      WHERE MOD(level,2) = 0
      CONNECT BY LEVEL <= 20 ;

 => waq to print all ascii charscters ?

      SELECT LEVEL , CHR(LEVEL) 
      FROM DUAL
      CONNECT BY LEVEL <= 256 ;

  O/P :- 
 
      ASCII  VALUE		CHAR

       65			A
       66			B

  => waq to print 2025 calendar ?

       01-jan-25	?
       02-jan-25	?

       31-dec-25	?

       SELECT   TO_DATE( '31-DEC-2024' , 'DD-MON-YYYY')+ LEVEL   AS DT,
                        TO_CHAR(TO_DATE( '31-DEC-2024' , 'DD-MON-YYYY')+ LEVEL,'DAY') AS DY
       FROM DUAL
       CONNECT BY LEVEL <= 365 ; 

 => query to print  triangle pattern ? 

       SELECT    LPAD(' ',10-LEVEL,' ')||
                         LPAD('*',LEVEL-1,'*')||
                         LPAD('*',LEVEL,'*')
     FROM DUAL 
     CONNECT BY LEVEL <= 10 ;
 
 => 

  SELECT SUBSTR('WELCOME',LEVEL,1) AS F1,
       SUBSTR('WELCOME',1,LEVEL) AS F2
FROM DUAL 
CONNECT BY LEVEL <= LENGTH('WELCOME')

Analytical Functions :- 
-----------------------------

RANK
DENSE_RANK
ROW_NUMBER
LAG
LEAD

RANK  & DENSE_RANK  :- 
------------------------------------

 => both functions are used to find  ranks 
 => ranks are based on one or more columns for  sal,hiredate,total marks
 => for rank functions data must be sorted 

        RANK()  OVER (ORDER BY colname ASC/DESC, -------)
        DENSE_RANK() OVER (ORDER BY colname ASC/DESC, ------)

 ex :- 

  => find ranks of the employees based on sal ?
       highest paid employee should get 1st rank ?

    SELECT  ename,sal,
                    RANK()  OVER (ORDER BY sal DESC) as rnk 
     FROM emp ; 
       
    SELECT  ename,sal,
                    DENSE_RANK()  OVER (ORDER BY sal DESC) as rnk 
     FROM emp ; 
   
    difference between RANK & DENSE_RANK   ?

    1  rank function generates gaps  but dense_rank will not generate gaps 
    2  in rank function ranks may not be in sequence but in dense_rank ranks are always in sequence

       SAL			RANK		DENSE_RANK
       5000			1		1
       4000			2		2
       3000			3		3
       3000			3		3
       3000			3		3
       2000			6		4
       2000			6		4
       1000			8		5

  => find ranks of the employees based on sal , if salaries are same then ranking 
       should be based on hiredate ?

       SELECT  ename,hiredate,sal,
                    DENSE_RANK()  OVER (ORDER BY sal DESC,hiredate ASC) as rnk 
      FROM emp  ;

   	 king       17-NOV-81       5000          1
	ford         03-DEC-81       3000          2
	scott        09-DEC-82       3000          3
	jones       02-APR-81       2975          4

  PARTITION BY clause :- 
  ----------------------------------

  => partition by clause is used to divide the table based on one or more columns.

  => used to find ranks with in group , for ex to find ranks with in dept 
       first  divide the table dept wise using partition by clause and apply
       rank / dense_rank functions on each partition 

 Ex :- 

   => find ranks with in dept based on sal  ? 
 
        SELECT  deptno,ename,sal,
                      DENSE_RANK() OVER (PARTITION BY deptno
                                                              ORDER BY sal DESC)  as rnk
        FROM emp
  
      10 	king             5000          1
           	clark            2450          2
          	 miller          1300          3

        20 	scott            3000          1
          	 ford             3000          1
           	jones            2975          2
           	adams         1100           3
           	smith            800            4

 ROW_NUMBER() :- 
 ------------------------

 => returns record number 
 => row_number is also based on one or more column
 => for row_number also data must be sorted 

   ROW_NUMBER()  OVER  (ORDER BY colname ASC/DESC,---)

 Ex 1  :-   row_number based on sal 

   SELECT  empno,ename,sal,
                   ROW_NUMBER() OVER (ORDER BY sal DESC) as rno
   FROM emp ;

     7839 king             5000          1
      7902 ford             3000          2
      7788 scott            3000          3
      7566 jones            2975          4
      7698 blake            2850          5
      7782 clark            2450          6

  Ex 2  :-   row_number based on empno
 
   SELECT   ROW_NUMBER() OVER (ORDER BY empno ASC) as rno,
                  empno,ename,sal              
   FROM emp ;
  
        1       7369 smith             800
         2       7499 allen            1600
         3       7521 ward             1250
         4       7566 jones            2975
         5       7654 martin           1250

     SAL		RNK		DRNK		RNO
     5000		1		1		1
     4000		2		2		2
     3000		3		3		3
     3000		3		3		4
     3000		3		3		5
     2000		6		4		6
     2000		6		4		7
     1000		8		5		8

 LAG & LEAD :- 
 ---------------------

  LAG(colname,number) OVER (ORDER BY ---)   => returns previous row value
  LEAD(colname,number) OVER (ORDER BY --)  => returns next row value

Ex 1 :- 

  SELECT  empno,ename,sal ,
                  LAG(sal,1) OVER (ORDER BY  empno ASC) as prev_sal
   FROM emp ; 
             
      7369    smith             800
      7499    allen             1600        800
      7521    ward             1250       1600
      7566    jones             2975      1250
      7654    martin           1250       2975
      7698    blake            2850       1250

Ex 2 :- 

    CREATE TABLE population
   (  
     year  NUMBER(4),
     population  NUMBER 
  ) ;

 INSERT INTO population VALUES(2020,1328024498)  
                                                        (2021,1402617695), 
                                                        (2022,1425423212), 
                                                        (2023,1438069596),
                                                        (2024,1450935791)

  SELECT * FROM POPULATION : 

  SELECT * FROM POPULATION ;

      YEAR POPULATION
      ---------- ----------
      2020 1328024498
      2021 1402617695
      2022 1425423212
      2023 1438069596
      2024 1450935791

  => display  YEAR    POPULATION   GROWTH  ? 

   SELECT year, population ,
                  population - LAG(population,1) OVER (ORDER BY year ASC) as growth
   FROM population ;
  
   YEAR POPULATION     GROWTH
---------- ---------- ----------
      2020 1328024498
      2021 1402617695   74593197
      2022 1425423212   22805517
      2023 1438069596   12646384
      2024 1450935791   12866195

  => display   year     population   growth      pct   ?

    pct  = ((current year population - prev year population)/(prev year pop))*100

   SELECT year,population,
                  population - LAG(population,1) OVER (ORDER BY year ASC) as growth ,
                  ((population - LAG(population,1) OVER (ORDER BY year ASC)) / LAG(population,1) OVER (ORDER BY year ASC) )*100 as pct
   FROM population ;
  
30-oct-25 

Multi-row functions :- 
----------------------------

=> these functions process multiple rows and returns one value
=> these functions are also called aggregate functions or group functions.

MAX
MIN
SUM
AVG
COUNT

MAX() :- 
-----------

 => returns maximum value

             MAX(arg)

Ex :- 

   SELECT MAX(sal) FROM emp ; 	 => 5000
   SELECT MAX(hiredate) FROM emp ; 	=>  12-jan-83
   SELECT MAX(ename) FROM emp ;	=>   ward

 MIN() :- 
 -----------

  =>  returns minimum value

             MIN(arg)

    SELECT MIN(sal) FROM emp ;  	 =>  800
    SELECT MIN(ename) FROM emp ; 	  => adams 

 SUM() :- 
 -----------

 => returns total

       SUM(arg) 

    SELECT SUM(sal) FROM emp ;   => 29025 

 => round total sal to hundreds ?

       SELECT ROUND(SUM(sal)  , -2)    FROM emp ;   => 29000

       29000-------------29050----------------------29100

  => after rounding display total sal with thousand seperator  and currency ?

     SELECT   TO_CHAR (ROUND(SUM(sal)  , -2) , 'L99G999')
     FROM EMP ; 

     O/P :-  $29,000
 
  C => currency =. USD
  L =>  currency symbol 
  G => group => thousand seperator

=> calculate total sal including comm ?

   SELECT  SUM(sal+comm)  FROM emp ;    => 9100

  SELECT SUM(sal+NVL(comm,0)) FROM emp  ;  => 31725

 => calculate total sal paid to managers ? 

      SELECT SUM(sal) FROM emp WHERE job='MANAGER' ; 

   How to use aggregate functions as analytical function  :- 
 ----------------------------------------------------------------------------

   Ex :-  SUM() OVER (ORDER BY ----)

   SELECT empno,ename,sal,
                 SUM(sal) OVER (ORDER BY empno ASC) as running_total
   FROM emp ; 

      7369 smith             800           800
      7499 allen            1600          2400
      7521 ward             1250          3650
      7566 jones            2975          6625
      7654 martin           1250          7875

  what is difference between analytical functions and aggregate functions ?

  => analytical functions returns one value for each row
  => aggregate functions returns one value from group of rows

AVG() :- 
-----------

  => returns average value
 
              AVG(arg) 

 Ex :- 

    SELECT  AVG(sal)  FROM emp ;    =>  2073.21429

 => round avg sal to lowest integer ? 

  SELECT FLOOR(AVG(sal)) FROM emp ;   => 2073

=> round avg sal to highest integer ?

    SELECT CEIL(AVG(sal)) FROM emp ;    => 2074 

  NOTE :- 

   => sum,avg cannot be applied on char,date fields can be applied only on
         numeric fields

     SELECT EMPNO,ENAME,SAL,
          AVG(SAL) OVER (ORDER BY EMPNO ASC)  as moving_avg
     FROM EMP ;

      7369 smith             800        800
      7499 allen            1600       1200
      7521 ward             1250      1216.66667
      7566 jones            2975      1656.25

COUNT() :- 
-------------

 => returns no of values present in a column 

                  COUNT(arg) 
 
Ex :- 

      SELECT COUNT(empno) FROM emp ;    => 14 
      SELECT COUNT(comm) FROM emp ;     => 5  => nulls are not counted

COUNT(*) :- 
-----------------

  => returns no of rows in a table
  
 SELECT COUNT(*) FROM emp ;   => 14 

  T1
  F1
 10
  NULL
 20
 NULL
30
                     COUNT(F1)  =>  3
                     COUNT(*)    =>  5
 
 => no of employees joined in 1981 year ? 

   SELECT  COUNT(*) 
   FROM emp 
  WHERE  EXTRACT(year from hiredate) = 1981 ; 

 => no of employees joined on sunday ?

   SELECT COUNT(*)
   FROM emp 
   WHERE  TO_CHAR(hiredate,'dy') = 'sun'  ;

  day   => sunday
 dy      =>  sun
 d        =>  1 

 => no of employees joined in 2nd quarter  of 1981 year ? 

   SELECT COUNT(*)
   FROM emp 
   WHERE  TO_CHAR(hiredate,'yyyy') =  1981 
                   AND
                  TO_CHAR(hiredate,'q') = 2 ; 

 NOTE :-

 =>  aggregate functions not allowed in where clause 

   SELECT  ename
   FROM emp 
   WHERE sal =  MAX(sal) ;    => ERROR  => to overcome use subquery


CHAR :-  upper,lower,initcap,length,substr,instr,lpad,rpad,ltrim,rtrim,trim,replace,translate
NUMERIC :-  round,ceil , floor,trunc,mod
DATE :-      extract , add_months,months_between
CONV :-    to_char ,to_date,to_number
SPECIAL  :-  nvl , chr,ascii
ANALYTICAL :-  rank ,dense_rank,row_number,lag,lead
AGGREGATE :-  max,min,sum,avg,count,count(*)


 ===========================================================================
 
31-oct-25

 GROUP BY clause :- 
 =================

 =>  GROUP BY clause is used to group rows based on one more column to calculate
       min,max,sum,avg,count for each group , for ex to calculate dept wise total sal
       first group the rows based on dept and apply sum function on each group 

      emp
     empno	   ename	 sal	deptno
      1	  A	3000	10
      2	 B	4000	20     GROUP BY		10	9000
      3	 C	5000	30   =============>	20	7000	
      4	 D	6000	10			30	5000
      5	 E	3000	20

       detailed data					summarized data 

  => group by clause converts detailed data into summarized data which is useful for analysis

  Syntax :- 
  ------------

  SELECT  columns
  FROM tabname
  [WHERE cond]
  GROUP BY col1,col2,---
  [HAVING cond]
  [ORDER BY  col ASC/DESC,---]


 Execution :- 
 ---------------

 FROM
 WHERE
 GROUP BY
 HAVING
 SELECT
 ORDER BY 

 Ex :- 

  => display  dept wise total salary ? 

      SELECT DEPTNO,SUM(SAL)
      FROM EMP
      GROUP BY DEPTNO ;

 FROM EMP :- 
 --------------------

     emp
      empno   ename	 sal	deptno
      1	  A	3000	10
      2	 B	4000	20     
      3	 C	5000	30    
      4	 D	6000	10			 
      5	 E	3000	20

  GROUP BY DEPTNO :- 
  -------------------------------

   10	1	A	3000
	4	D	6000

   20	2	B	4000
	5	E	3000

  30	3	C	5000

 SELECT DEPTNO,SUM(SAL)  :- 
 ----------------------------------------------

   10	9000
   20	7000
   30	5000
   
 => display job wise summary  ( min sal,max sal,total sal,avg sal,no of emps)  ?

      SELECT   job,MIN(sal) as minsal,
                             MAX(sal) as maxsal,
                             SUM(sal) as totsal,
                             AVG(sal) as avgsal,
                             COUNT(*) as cnt
      FROM emp 
      GROUP BY  job  ; 

  => display year wise no of employees joined ? 
 
      SELECT  TO_CHAR(hiredate,'yyyy') as year, COUNT(*) as no_of_emps
      FROM emp 
      GROUP BY TO_CHAR(hiredate,'yyyy') ;

  YEAR	 NO_OF_EMPS
----------	 ----------
1981         10
1983          1
1980          1
1982          2

  
                    GROUP  BY   year     =>  invalid
                    ORDER BY year ASC  =>  valid

  NOTE :- 
  ------------

  =>  alias cannot be used in group by clause because group by clause is executed before select
  => alias can be used in order by clause because order by is executed after select.
    
 => display month wise no of employees joined in the year 1981 ?

       SELECT TO_CHAR(hiredate,'month') as month,COUNT(*)
       FROM emp 
       WHERE TO_CHAR(hiredate,'yyyy') = 1981 
       GROUP BY TO_CHAR(hiredate,'month') ;
   
=> find the departments having more than 3 employees ? 

     SELECT  deptno,COUNT(*)
     FROM emp 
     WHERE COUNT(*) > 3 
     GROUP BY deptno ;        => ERROR

   => oracle cannot calculate dept wise count before group by and it can 
        calculate only after group by , so apply the condition COUNT(*) > 3
        after group by using HAVING clause.

     SELECT  deptno,COUNT(*)
     FROM emp 
     GROUP BY deptno  
     HAVING COUNT(*) > 3 ;

	20	5
	30	6

 WHERE VS HAVING :- 
 -------------------------------

	WHERE				HAVING

1	selects specific rows			selects specific groups 

2	conditions applied before group by	conditions applied after group by

3	use where clause if cond                             use having clause
                 doesn't contain aggregate                           if cond contains
                 function				  aggregate function
      
 =>  find southern states having more than 5cr population ? 

    persons
    aadharno    name    gender   dob    addr   city   state   region

     SELECT  state,COUNT(*)
     FROM persons
     WHERE   region = 'south' 
     GROUP BY state 
     HAVING COUNT(*) > 50000000 ;
 
 => display job wise no of employees 
      where job = clerk,manager 
      no of emps > 3  ? 

      SELECT job,COUNT(*)
      FROM emp 
      WHERE job IN ('CLERK','MANAGER')
      GROUP BY job
      HAVING COUNT(*) > 3 ; 

 1-nov-25 

  Grouping based on multiple columns :- 
  ---------------------------------------------------------
 
    => display dept wise and with in dept job wise total sal ?

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY deptno,job
         ORDER BY deptno ASC 


 	10	clerk		1300
	10	manager		2450
	10	president		5000

	20	analyst		6000
	20	clerk		1900
	20	manager		2975
	
	30	clerk		950
	30	manager		2850
	30	salesman		5600

   => display year wise and with in year quarter wise no of employees joined ?

        1980		1	?
		2	?
		3	?
		4	?

         1981	1	?
		2	?
		3	?
		4	?

         SELECT  TO_CHAR(hiredate,'yyyy') as year,
                         TO_CHAR(hiredate,'q') as qrt,
                         COUNT(*) as no_of_emps
         FROM emp 
         GROUP BY  TO_CHAR(hiredate,'yyyy') , TO_CHAR(hiredate,'q')
         ORDER BY  year ASC ,qrt ASC ;
 
	YEAR Q NO_OF_EMPS
 
	1980 	4          1

	1981 	1          2
    		2          3
     		3          2
     		4          3

	1982 	1          1
     		4          1

	1983 	1          1
  
 ROLLUP & CUBE :- 
 ----------------------------

 => both functions are used to calculate subtotals and grand total 

                  GROUP BY ROLLUP(col1,col2,--)
                  GROUP BY CUBE(col1,col2,------)

 ROLLUP :- 
 ----------------
 
 => rollup  displays subtotals for each group and also displays grand total

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY ROLLUP(deptno,job)
         ORDER BY deptno ASC  ;

	10 	CLERK           	1300
           		MANAGER         	2450
           		PRESIDENT     	5000
                          			 8750

        	20 	ANALYST         	6000
          		 CLERK           	1900
           		MANAGER          	2975
                         			10875

        	30	 CLERK           	 950
           		MANAGER        	 2850
          	 	SALESMAN       	 5600
                           			 9400

                          			29025

CUBE :- 
-----------

=> cube displays subtotals for each group by column (deptno,job)  and
     also displays grand total.

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY CUBE(deptno,job)
         ORDER BY deptno ASC  ;

	10 	CLERK           	1300
           		MANAGER         	2450
           		PRESIDENT     	5000
                          			 8750

        	20 	ANALYST         	6000
          		 CLERK           	1900
           		MANAGER          	2975
                         			10875

        	30	 CLERK           	 950
           		MANAGER        	 2850
          	 	SALESMAN       	 5600
                           			 9400

		 ANALYST        	 6000
         		 CLERK           	4150
          		 MANAGER        	 8275
          		 PRESIDENT       	5000
           		 SALESMAN        	5600

                          			29025

 => display state wise and with in state  gender wise population 
      and also display state wise and gender wise subtotals ?

   persons
   aadharno    name   gender    dob    addr    city   state     region

    SELECT  state,gender,COUNT(*) as population
    FROM persons
    GROUP BY  CUBE(state ,gender)
    ORDER BY state ASC
   
      AP	male		?
	female		?
			??

     AR	male		?
	female		?
			??

     AS	male		?
	female		?
			??

	male		?
	female		?

			??

3-nov-25 

GROUPING SETS :-
---------------------------

 => In Oracle SQL, GROUPING SETS is an extension to the GROUP BY clause
       that allows you to specify multiple groupings of data within a single query. 
       Unlike ROLLUP or CUBE, which generate a predefined set of aggregations, 
       GROUPING SETS  allows  user to specify aggregations .

Ex 1  :- 

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY GROUPING SETS ((deptno,job))
         ORDER BY deptno ASC ,job ASC ; 

  
 	10	clerk		1300
	10	manager		2450
	10	president		5000

	20	analyst		6000
	20	clerk		1900
	20	manager		2975
	
	30	clerk		950
	30	manager		2850
	30	salesman		5600

Ex 2 :- 

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY GROUPING SETS ((deptno,job) , (deptno))
         ORDER BY deptno ASC ,job ASC ; 

 	10	clerk		1300
	10	manager		2450
	10	president		5000
				8750

	20	analyst		6000
	20	clerk		1900
	20	manager		2975
				10875
	
	30	clerk		950
	30	manager		2850
	30	salesman		5600
				9400

Ex 3 :- 

         SELECT  deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY GROUPING SETS ((deptno,job) , (deptno) , (job) , ())
         ORDER BY deptno ASC ,job ASC ; 
 
	10	clerk		1300
	10	manager		2450
	10	president		5000
				8750

	20	analyst		6000
	20	clerk		1900
	20	manager		2975
				10875
	
	30	clerk		950
	30	manager		2850
	30	salesman		5600
				9400

		 analyst		6000
		 clerk		4150


				29025

GROUPING_ID() :-
--------------------------

=> this function accepts group by columns and returns subtotal belongs to 
     which group by column 

         Ex :-   GROUPING_ID (deptno,job)

		1	=> if subtotal belongs to 1st column i.e. deptno
		2               => if subtotal belongs to 2nd column i.e. job
		3               => grand total 
			
 
         SELECT  deptno,job,SUM(sal) as totsal,
                         CASE grouping_id(deptno,job) 
                         WHEN 1 THEN 'Dept subtotal'
                         WHEN 2 THEN 'Job subtotal'
                         WHEN 3 THEN 'Grand Total'
                         END as subtotal
         FROM emp 
         GROUP BY GROUPING SETS ((deptno,job) , (deptno) , (job) , ())
         ORDER BY deptno ASC ,job ASC ; 

 summary :- 
-----------------

 importance of group by 
 writing queries using group by
 where vs having
 rollup & cube
 grouping sets
 grouping_id

===============================================================

			Integrity Constraints
			=================


 => Integrity Constraints are rules to maintain data integrity i.e. data quality or data consistency
 => used to prevent users from entering invalid data.
 => used to enforce rules like min bal must be 1000

 Types of constraints :- 
 -----------------------------

1  NOT NULL
2  UNIQUE
3  PRIMARY KEY
4  CHECK
5  FOREIGN KEY
6  DEFAULT
 
=> above constraints can be declared in two ways 

 1  column level
 2  table level

 column level :- 
 --------------------

  => if constraints are declared  immediately after declaring column then it is called
       column level.

    CREATE TABLE <tabname>
    (
         colname  datatype(size)   constraint ,
         colname  datatype(size)   constraint,
          ---------------
     );

NOT NULL :- 
------------------

  => NOT NULL constraint doesn't accept null values 
  => a field declared with NOT NULL is called mandatory field

  Ex :- 

  CREATE TABLE emp11
  (
      empno  NUMBER(4),
      ename  VARCHAR2(10)  NOT NULL
   );

 INSERT INTO emp11 VALUES(100,'') ;   => ERROR
 INSERT INTO emp11 VALUES(101,'A') ; 

UNIQUE :-
-------------

=> unique constraint doesn't accept duplicates

 Ex :- 

 CREATE TABLE cust123
 ( 
   cid  NUMBER(2),
   cname VARCHAR2(10) NOT NULL,
   emailid  VARCHAR2(20) UNIQUE
 );

 INSERT INTO cust123 VALUES(10,'A','abc@gmail.com') ; 
 INSERT INTO cust123 VALUES(11,'B','abc@gmail.com') ;  => ERROR
 INSERT INTO cust123 VALUES(12,'C','');  
 INSERT INTO cust123 VALUES(13,'D','');                            => allowed

 NOTE :- 

 => UNIQUE constraint doesn't accept duplicates but allows nulls.

 PRIMARY KEY :- 
 ----------------------

 => primary key doesn't accept duplicates and nulls.
 => primary key is combination of unique and not null.

      primary key = unique + not null

 => In tables one column must be there to uniquely identify and into that
      column duplicates and nulls are not allowed , so declare that column with
       primary key.

   Ex :- 

   CREATE TABLE emp15
   (
     empno  NUMBER(4)  PRIMARY KEY,
     ename  VARCHAR2(10) NOT NULL 
   );

  INSERT INTO emp15 VALUES(10,'A') ; 
  INSERT INTO emp15 VALUES(10,'B') ;   => ERROR
  INSERT INTO emp15 VALUES(null,'C');  => ERROR

 because it is not allowing duplicates and nulls into empno , so using empno
 we can uniquely identify employees.

 NOTE :- 
-----------

 => only one primary key is allowed per table , if we want multiple primary keys
      then declare one column with primary key and other columns with
      unique not null.
 
Ex :- 

    create table customers
    (
      custid    NUMBER(6)  PRIMARY KEY,
      cname  VARCHAR2(10) NOT NULL,
      emailid  VARCHAR2(20) UNIQUE,
      aadharno NUMBER(12)  UNIQUE NOT NULL,
      panno     CHAR(10) UNIQUE NOT NULL
   );

 difference between UNIQUE  & PRIMARY KEY  ?

	UNIQUE				PRIMARY KEY

1	allows nulls			doesn't allow nulls 

2	a table can have			a table can have
	multiple unique			only one primary key
	constraints

 candidate key :- 
 -----------------------

 => a field eligible for primary key is called candidate key

  Ex :- 
             VEHICLES
             vehno     name    model    cost     chassisno
	
              candidate keys :-  vehno , chassisno
              primary key      :-   vehno
              secondary key  :-  chassisno
              or
              alternate key

  => while creating table secondary keys are declared with UNIQUE NOT NULL.

 4-nov-25 

 CHECK :- 
 ---------------

  => use check constraint when rule based on condition

                        CHECK(condition)

  Ex  1   :-    sal  must be min 3000

    create table emp16
    (
       empno  NUMBER(4)  PRIMARY KEY,
       ename VARCHAR2(10) NOT NULL,
       sal     NUMBER(7)  CHECK(sal >= 3000)   NOT NULL
    );

    INSERT INTO emp16 VALUES(100,'A',1000);   => ERROR
    INSERT INTO emp16 VALUES(101,'B',5000);
    INSERT INTO emp16 VALUES(102,'C',NULL);

 NOTE :- check constraint allows null values 

 Ex 2 :-  gender  must be  'm','f'  

          GENDER   CHAR(1)   CHECK(gender='m' or gender='f')

 Ex 3  :-   amt must be multiple of 100

          AMT    NUMBER(6)   CHECK(MOD(amt,100)=0)

Ex 4   :-   pwd  must be min 6 chars  

          PWD   VARCHAR2(12)   CHECK(LENGTH(pwd) >= 6)

Ex 5  :-  emailid   must contain  '@'
                            must end with  '.com'   or   '.co'   or   '.in'  

            EMAILID  VARCHAR2(20) CHECK(emailid  LIKE  '%@%'
                                                                     AND 
                                                                     (
                                                                       emailid LIKE  '%.com'
                                                                       OR
                                                                       emailid LIKE  '%.co'
                                                                       OR
                                                                       emailid LIKE  '%.in'
                                                                       ))

  FOREIGN KEY :- 
  ------------------------

  => foreign key is used to establish relationship between two tables 

  => To establish relationship between two tables then take primary key
       of one table and add it to another table as foreign key and declare
       with references constraint.

ex :- 

projects
projid	name	duration	   cost     client
1000	AAA	5 YEARS	   400      TATA MOTORS
1001	BBB	3  YEARS   200       DBS BANK

emp
empid	ename	job	sal	projid   REFERENCES projects(projid)
100	K	SE	30K	1000 
101	D	SSE	80K          1001
102	S	TL            100K         9999  => not accepted
103	J	SE	25K	1000
104	G	SE	30K	NULL

=> values entered in fk column should match with values entered in pk column 

=>  fk allows duplicates and nulls.

 => after declaring fk a relationship is created between two tables called
      parent / child relationship

=> pk table is parent and fk table is child

CREATE TABLE projects
(
  projid  number(4)  primary key,
  pname  varchar2(10)
 );

 INSERT INTO projects VALUES(1000,'AAA');
 INSERT INTO projects VALUES(1001,'BBB');

 CREATE TABLE emp_proj
 (
   empno  NUMBER(3) PRIMARY KEY,
   ename VARCHAR2(10) NOT NULL,
   sal       NUMBER(7) CHECK(sal>=3000),
   projid   NUMBER(4)  REFERENCES projects(projid)
 );

INSERT INTO emp_proj VALUES(100,'A',5000,1000);
INSERT INTO emp_proj VALUES(101,'B',4000,9999); => ERROR
INSERT INTO emp_proj VALUES(102,'C',3000,1000);
INSERT INTO emp_proj VALUES(103,'D',3000,NULL);

Relationship Types :-
-----------------------------

1   one to one (1:1)
2   one to many (1:m)
3   many to one (m:1)
4   many to many  (m:n)

=> by default oracle creates one to many relationship between two tables

How to establish 1:1 relationship :-
----------------------------------------------

=> To establish 1:1 relationship between two tables declare foreign key with
      unique constraint.

 DEPT			MGR
 DNO	DNAME		MGRNO	MNAME	  DNO   REFERENCES DEPT(DNO)    UNIQUE
 10	HR		100		  10
 20	IT		101		  20
 30	SALES		102                             30

How to establish m:n relationship :-
----------------------------------------------

=> To establish m:n relationship between two tables  then create 3rd
      table and add primary keys of both tables as foreign keys.

Ex :- 

 COURSE			STUDENT
 cid	cname		sid	sname
 10	JAVA		1	A
 11	ORACLE		2	B

 REGISTRATIONS
 sid        cid      dor      fee
 1          10       --	   5000
 1          11       ---         3000
 2          10       --          5000

	
	ER Model			Relational Model

 1	model used in db design	model used in db development

  2	Entities			Tables

  3	Attributes			Fields

  4	Relationship		Foreign key

Relaitonal Model for the above ER Model :-
--------------------------------------------------------

BANK
CODE	NAME	ADDR
---------

BRANCH
BRANCH_ID	NAME	ADDR	  CODE(FK)
-----------------

ACCOUNT
ACCNO	ACTYPE	BAL	BRANCH_ID (FK)         CUSTID (FK)
-----------

LOAN
LOAN_ID   	LOAN_TYPE	AMOUNT		BRANCH_ID (FK)       CUSTID(FK)
-------------

CUSTOMER
CUSTID	NAME	ADDR	PHONE
 ------------

 Rules for adding fk :- 
 ----------------------------

1  if relationship is 1:1 then fk can be added to any table
2  if relationship is 1:m then fk must be added to many side table
3  if relationship is m:n then create 3rd table add pks of both tables as fks
 
 5-nov-25 

 DEFAULT :- 
 ---------------

 =>  a  column can be declared with default value as follows 

    ex :-     hiredate   date    default   sysdate

 => while inserting if we skip hiredate then oracle inserts default value

      CREATE TABLE emp20
      (
       empno  NUMBER(4) PRIMARY KEY,
       ename VARCHAR2(10) NOT NULL,
       hiredate DATE DEFAULT SYSDATE
     );
  
      INSERT INTO emp20(empno,ename) VALUES(100,'A');
      INSERT INTO emp20  VALUES(101,'B','10-FEB-25');
      INSERT INTO emp20  VALUES(102,'C','');
 
   SELECT * FROM emp20;

       100 A          05-NOV-25
       101 B          10-FEB-25
       102 C

Assignment :-
-------------------

 ACCOUNTS
accno	actype	bal

 rules :- 
 -------

 1  accno should not be duplicate & null
 2  actype must be 'S' OR 'C'
 3  bal must be min 1000

TRANSACTIONS
trid	ttype	tdate	tamt	accno

rules :-
---------

 1 trid should not be duplicate & null
 2 ttype must be 'w' or 'd'
 3 tdate must be sysdate
 4 tamt must be multiple of 100
 5 accno should match with accounts table  accno
 6 accno should not be null

TABLE LEVEL :- 
------------------------
 
=> if constraints are declared after declaring all columns then it is called table level
=>  use table level to declare constraints for multiple or combination of columns
 
 Declaring check constraint at table level :- 
 -----------------------------------------------------

 products
 prodid	pname	price	mfd_dt		exp_dt
 100	A	50	5-NOV-25		1-NOV-25    => INVALID

           Rule :-  exp_dt  > mfd_dt 

  CREATE TABLE products
  (
    prodid  NUMBER(4) PRIMARY KEY,
    pname VARCHAR2(10) NOT NULL,
   price   NUMBER(5),
   mfd_dt  DATE ,
   exp_dt  DATE ,
                CHECK(exp_dt > mfd_dt)
  )
 
  INSERT INTO products VALUES(100,'A',50,SYSDATE,'01-NOV-25'); => ERROR
  INSERT INTO products VALUES(100,'A',50,'01-NOV-25',SYSDATE);

Composite primary key :-
-----------------------------------

 => if primary key declared for combination of columns then it is called
      composite primary key

 => In some table we may not be able to uniquely identify using single column
      and we need combination of columns to uniquely identify and that
      combination should be declared primary key at table level.

 Ex 1  :- 

 student			course
sid	sname		cid	cname
----			----
1	A		10	java
2	B		11	oracle

registrations
sid	cid	dor	fee
------------------
1	10	?	?
1	11	?	?
2	10	?	?
 
 create table student
 (
  sid number(2) primary key,
  sname varchar2(10) not null
  ) ;
 
  insert into student values(1,'A');
  insert into student values(2,'B');
  
  create table course
  (
  cid number(2) primary key,
  cname varchar2(10) not null
  );

 insert into course values(10,'java');
 insert into course values(11,'oracle');

 create table registrations
 (
    sid  number(2)   references student(sid) , 
    cid  number(2)   references course(cid) ,
    dor   date ,
    fee   number(5) ,
              PRIMARY KEY(sid,cid)
  );

 insert into registrations values(1,10,sysdate,5000);
 insert into registrations values(1,11,sysdate,5000);
 insert into registrations values(2,10,sysdate,5000);
 insert into registrations values(1,10,sysdate,5000);  => ERROR

  Ex 2  :- 

  sales
  dateid	prodid	custid	qty	amt
  4-nov     100	10	1	2000
  4-nov     101	10	1	1000
  4-nov     100            11	1	2000
  5-nov	100	10	 1	2000

  => identity primary key and write create table script ?

Composite foreign key :-
---------------------------------

 => if combination of columns declared foreign key then it is called composite 
      foreign key.

 => a composite foreign key refers composite primary key

Ex :- 

 registrations
sid	cid	dor	fee
------------------
1	10	?	?
1	11	?	?
2	10	?	?

certificates
certno       doi     sid	   cid
1000	4-       1	    10
1001	4-       1	    11
1002	4-       2	    11

 => in the above ex  sid,cid combination should match with registrations table
      sid,cid combination , so declare this combination as foreign key at table level

Questions :-

1  Which of the following constraint cannot be declared at table level ?

  A  UNIQUE
  B  CHECK
  C   NOT NULL
  D   PRIMARY KEY
  E   FOREIGN KEY

  ANS :-    C 

 2  Which statements are true regarding constraints ?

A  a foreign key cannot contain NULL value     F 
B  a column with UNIQUE constraint can contain NULL value  T
C  a constraint is enforced only for the INSERT operation on a table  F
D all constraints can be defined at column level and table level.    F

3  Which CREATE TABLE statement is valid?

A. CREATE TABLE ord_details
(ord_no NUMBER(2) PRIMARY KEY,
item_no NUMBER(3) PRIMARY KEY,
ord_date DATE NOT NULL);

B. CREATE TABLE ord_details
(ord_no NUMBER(2) UNIQUE, NOT NULL,
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL);

C. CREATE TABLE ord_details
(ord_no NUMBER(2) ,
item_no NUMBER(3),
ord_date DATE DEFAULT NOT NULL,
 UNIQUE (ord_no),
  PRIMARY KEY (ord_no));

D. CREATE TABLE ord_details
(ord_no NUMBER(2),
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL,
  PRIMARY KEY (ord_no, item_no));

4  Evaluate the following CREATE TABLE commands

CREATE TABLE orders
(ord_no NUMBER(2)  PRIMARY KEY,
ord_date DATE,
cust_id NUMBER(4));

CREATE TABLE ord_items
(ord_no NUMBER(2),
item_no NUMBER(3),
qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),
expiry_date date CHECK (expiry_date > SYSDATE),
  PRIMARY KEY (ord_no,item_no),
  FOREIGN KEY(ord_no) REFERENCES orders(ord_no));

The above command fails when executed. What could be the reason?

A. SYSDATE cannot be used with the CHECK constraint.  T
B. The BETWEEN clause cannot be used for the CHECK constraint. F
C. The CHECK constraint cannot be placed on columns having the DATE data type. F
D. ORD_NO and ITEM_NO cannot be used as a composite primary key 
 because ORD_NO is also the FOREIGN KEY.  F

6-nov-25 

Adding constraints to existing table :- 
--------------------------------------------------

 =>  "ALTER"  command is used to add constraints to existing table

Ex :- 

 CREATE TABLE  emp55
 (
    empno  NUMBER(4),
    ename VARCHAR2(10)   ,
    sal   NUMBER(7,2) ,
    emailid  VARCHAR2(20),
    deptno  NUMBER(2)              
   );

Adding primary key :- 
-----------------------------

 => add pk to empno  ? 

  ALTER TABLE emp55
            ADD PRIMARY KEY(empno) ; 

Adding check constraint :- 
-------------------------------------

 => add check constraint with condition  sal >= 3000 ?

  ALTER TABLE emp55
          ADD CHECK(sal >= 3000);

 ALTER TABLE emp 
          ADD CHECK(sal >= 3000);   => ERROR  => some of the employee salaries are 
					less than 3000

 while adding constraint oracle also validates existing data , if existing data doesn't
 satisfy the condition then constraint cannot be added.

 NOVALIDATE :- 
 ---------------------

  => if check constraint is added with NOVALIDATE then oracle will not validate
       existing data and it validates only new data.

 ALTER TABLE emp 
          ADD CHECK(sal >= 3000)  NOVALIDATE ; 

 Adding unique constraint :- 
--------------------------------------

  => add unique constraint to emailid ?

    ALTER TABLE emp55
               ADD UNIQUE (emailid) ; 

Adding foreign key :-
------------------------------

 => add fk to deptno  that should match with dept table primary key i.e. deptno ?

   ALTER TABLE emp55
          ADD  FOREIGN KEY(deptno)  REFERENCES dept(deptno)  ; 

Changing from NULL to NOT NULL :-
-----------------------------------------------------

 => Modify the column ename to NOT NULL ?

     ALTER TABLE emp55
              MODIFY (ename NOT NULL) ; 


Data Dictionary Tables :- 
-----------------------------------

 => oracle not only stores data and it also stores metadata that includes information
      about users,tables,constraints etc.

   ALL_USERS :- 
  ----------------------

  => stores information about users created in db.

  SQL>DESC  ALL_USERS

   USERNAME
   CREATED 
  
   => display list of users ?

      SELECT USERNAME FROM ALL_USERS ; 

  => list of users name starts with 'B'  ?

     SELECT USERNAME FROM ALL_USERS WHERE USERNAME LIKE 'B%' ; 

  => find on which day (date)  batch53 user is created ?

    SELECT CREATED FROM ALL_USERS WHERE USERNAME='BATCH53' ;

 
USER_TABLES :- 
 -------------------------

 => stores tables created by user
  
  list of tables created by user ? 

  SELECT TABLE_NAME FROM USER_TABLES ;

  how many tables created by user ? 

  SELECT COUNT(*) FROM USER_TABLES ; 

 USER_CONSTRAINTS :- 
 ------------------------------------

=> stores constraints declared in a table

  list of constraints declared in emp55 table ? 

   SELECT  CONSTRAINT_NAME , CONSTRAINT_TYPE ,
                  SEARCH_CONDITION
   FROM USER_CONSTRAINTS 
   WHERE TABLE_NAME = 'EMP55' ; 

 CONSTRAINT_NAME     	 C 	SEARCH_CONDITION
-------------------- 	         	 ---	-----------------------------
SYS_C0010396        	 P
SYS_C0010397        	 C 	 sal >= 3000
SYS_C0010399        	 U
SYS_C0010401        	 R
SYS_C0010402         	 C 	"ENAME" IS NOT NULL

Droping constraints :- 
----------------------------

  ALTER TABLE <tabname>
            DROP  CONSTRAINT  <name> ;

Ex :- 

  => drop check constraint in emp55 table ?

      ALTER TABLE emp55
              DROP  CONSTRAINT SYS_C0010397  ;

 => drop primary key in emp55 table ? 

     ALTER TABLE emp55
           DROP CONSTRAINT SYS_C0010396   ; 

   ALTER TABLE emp55
            DROP  PRIMARY KEY ; 

  => drop primary key in dept table ?

    ALTER TABLE dept
           DROP  PRIMARY KEY ;   => ERROR  

   DROP TABLE dept;   => ERROR

 =>   pk constraint cannot be dropped if referenced by some fk
 =>   pk table cannot be dropped if referenced by some fk

CASCADE :-
-------------------

   ALTER TABLE dept
          DROP  PRIMARY KEY CASCADE ;  => drops pk along with fk 

   DROP TABLE dept  CASCADE CONSTRAINTS ;  => drops table with dependent fk

7-nov-25 

DELETE rules :- 
--------------------
 
1  ON DELETE NO ACTION  (DEFAULT)
2  ON DELETE CASCADE
3  ON DELETE SET NULL

 => These rules are declared with foreign key
 => delete rule specifies how child rows are affected if parent row is deleted
   
 ON DELETE NO ACTION :- 
-----------------------------------------

 => parent row cannot be deleted if it has child rows

CREATE TABLE dept77
(
 dno  NUMBER(2)  PRIMARY KEY,
 dname VARCHAR2(10) NOT NULL
);
   INSERT INTO dept77  VALUES(10,'HR');
   INSERT INTO dept77  VALUES(20,'IT');

CREATE TABLE emp77
(
  empno NUMBER(4) PRIMARY KEY,
  ename VARCHAR2(10) NOT NULL,
  dno   NUMBER(2) REFERENCES dept77(dno)
 );

INSERT INTO emp77 VALUES(1,'A',10);
INSERT INTO emp77 VALUES(2,'B',10);

 DELETE FROM dept77 WHERE dno = 10;   => ERROR

 DELETE FROM dept77 WHERE dno = 20 ;   => DELETED 

scenario :- 
---------------

 ACCOUNTS
 accno	actype	bal
 100
 101

 LOANS
 id	type	amt	accno REFERENCES accounts(accno)  
 1	H	30	100
 2	C	10	100

Rule :- accout closing is not possible if associated with loans 

ON DELETE CASCADE :- 
-------------------------------------

 =>  parent row is deleted along with child rows 


CREATE TABLE dept77
(
 dno  NUMBER(2)  PRIMARY KEY,
 dname VARCHAR2(10) NOT NULL
);
   INSERT INTO dept77  VALUES(10,'HR');
   INSERT INTO dept77  VALUES(20,'IT');

CREATE TABLE emp77
(
  empno NUMBER(4) PRIMARY KEY,
  ename VARCHAR2(10) NOT NULL,
  dno   NUMBER(2) REFERENCES dept77(dno)   ON DELETE CASCADE
 );

INSERT INTO emp77 VALUES(1,'A',10);
INSERT INTO emp77 VALUES(2,'B',10);

DELETE FROM dept77 WHERE  dno = 10;   => 1 row deleted

 SELECT * FROM emp77 ;  => no rows 

scenario :-
-------------

 ACCOUNTS
 accno	actype	bal
100
101

 TRANSACTIONS
  trid	ttype	tdate	tamt	accno       REFERENCES accounts(accno)
 1	W	?	2000	100           ON DELETE CASCADE
 2	D	?	4000	100
 
Rule :-  if account is closed along with account delete transactions also 

 ON DELETE SET NULL :-
-----------------------------------

=> parent row is deleted  without deleting child rows but fk will be set to null

CREATE TABLE dept77
(
 dno  NUMBER(2)  PRIMARY KEY,
 dname VARCHAR2(10) NOT NULL
);
   INSERT INTO dept77  VALUES(10,'HR');
   INSERT INTO dept77  VALUES(20,'IT');

CREATE TABLE emp77
(
  empno NUMBER(4) PRIMARY KEY,
  ename VARCHAR2(10) NOT NULL,
  dno   NUMBER(2) REFERENCES dept77(dno)   ON DELETE SET NULL
 );

INSERT INTO emp77 VALUES(1,'A',10);
INSERT INTO emp77 VALUES(2,'B',10);

DELETE FROM DEPT77 WHERE DNO=10;  => 1 ROW DELETED

SELECT * FROM EMP77 ;

     EMPNO   ENAME             DNO
      ----------   ----------             - --------
         1            A
         2            B

scenario :- 
---------------

PROJECT
projid	pname	duration	 cost	client
1000
1001

EMP
empno	ename	sal	job	projid  REFERENCES projects(projid)
1				1000   ON DELETE SET NULL
2				1001

rule :- 

 => if project is completed (deleted)  then set employee project id to null


summary :- 

 purpose of constraints
 types of constraints
 declaring constraints
       column level
       table level
 adding constraints to existing table
 droping constraints
 delete rules
 getting constraints information

=========================================================================

			JOINS
			======

 =>  join is an operation performed to display data from two or more table

 =>  to display data from two tables we need to join those table

 =>  In DB , related data is not stored in one table and it is stored in multiple tables ,
       To gather or to combine data stored in multiple tables we need to join those table.

 Ex :- 

 ORDERS				   CUST
 ordid	orddt	deldt	cid	   cid	name	addr
 1000			10	   10	A	HYD
 1001			11	   11	B	HYD
 1002			12	   12	C	HYD

 OUTPUT :- 

  ordid	orddt	deldt	cname	addr
 1000	?	?	A	HYD

Types of join :- 
---------------------

1 Inner join
       equi join
       non equi join
       self join
2 Outer join
       left outer join
       right outer join
       full outer join
 3  cross / cartesian join

 Equi join :- 
-----------------

 => Equi join is performed between the tables sharing common field
 => Name of the common field need not to be same
 => between the tables pk-fk relationship is not compulsory
 => Equi join is performed based on the common field with same datatype.

  SELECT columns
  FROM  tab1 INNER JOIN tab2
  ON  join condition ;

 join condition :- 
-------------------------

  =>  join condition determines which record of 1st table joined with which record of  2nd table
 =>   based on the join condition oracle joins the records of two tables

                    TABLE1.commonfield  =  TABLE2.commonfield

Ex :- 
 
  EMP				 	DEPT
  empno	ename	    sal	 deptno		deptno	dname		loc
   7369 	smith             800          20		10	ACCOUNTS	NEW YORK
   7499 	allen             1600         30		20	RESEARCH
   7521	 ward            1250         30		30	SALES
   7566 	jones            2975         20		40	OPERATIONS
   7782 	clark             2450         10
   9999	vijay	   2000	     null		 

 => display employee details with dept details ? 

   SELECT empno,ename,sal,dname,loc
   FROM emp INNER JOIN dept 
   ON  emp.deptno = dept.deptno  ;

   7369	smith	 700	research	?
   7499	allen	1600	sales	?
   7521	 ward         1250    	sales	?
   7566   	jones         2975        research   ?
   7782 	clark           2450       accounts   ?
   
NOTE :- 

 => In join queries declare table alias and prefix column names with table alias for two reasons 

  1  to avoid ambiguity error
  2  for faster execution

  SELECT    e.empno,e.ename,e.sal,
                    d.deptno,d.dname,d.loc as city
   FROM emp  e  INNER JOIN dept  d
   ON  e.deptno = d.deptno  ;

    => display employee details with dept details working at NEW YORK loc 
         and earning more than 2000 ?
 
     SELECT    e.empno,e.ename,e.sal,
                       d.deptno,d.dname,d.loc as city
     FROM emp  e  INNER JOIN dept  d
     ON  e.deptno = d.deptno     /*   join condition  */
     WHERE d.loc = 'NEW YORK'   
                    AND
                    e.sal  > 2000  /* filter condition */  ;

 => display order details with cust details to be delivered today ?

 ORDERS				   CUST
 ordid	orddt	deldt	cid	   cid	name	addr
 1000			10	   10	A	HYD
 1001			11	   11	B	HYD
 1002			12	   12	C	HYD
  
  SELECT o.*, c.*
  FROM orders o INNER JOIN cust c
  ON o.cid = c.cid
  WHERE TRUNC(o.deldt)  = TRUNC(sysdate) ; 

8-nov-25

  joining more than two tables :- 
  -----------------------------------------
 
 => if no of tables increases no of join conditions also increases 
 => to join N tables N-1 join conditions required

 SELECT columns
 FROM tab1 INNER JOIN tab2
 ON join condition
                    INNER JOIN  tab3
 ON join condition
                   INNER JOIN tab4
  ON join condition ;

  ( tab1 join tab2)   join tab3 )  join tab4

Ex :- 

employees	departments	locations		countries

employee_id	department_id	location_id	country_id
first_name	department_name	city		country_name
last_name		location_id	state
salary				country_id
department_id

display   ename     dname     city     state    country_name   ? 

 SELECT  e.first_name||' '||e.last_name as ename ,
                 d.department_name as dname,
                 l.city , l.state,
                 c.country_name as country
  FROM    employees e INNER JOIN departments d
  ON         e.department_id = d.department_id
                                     INNER JOIN locations l
  ON         d.location_id = l.location_id
                                     INNER JOIN countries c
   ON        l.country_id = c.country_id ;

 OUTER JOIN :- 
 -------------------

 => equi join returns only matching records but will not return unmatched records
      to display unmatched records perform outer join.

 Ex :- 
 
  EMP				 	DEPT
  empno	ename	    sal	 deptno		deptno	dname		loc
   7369 	smith             800          20		10	ACCOUNTS	NEW YORK
   7499 	allen             1600         30		20	RESEARCH
   7521	 ward            1250         30		30	SALES
   7566 	jones            2975         20		40	OPERATIONS  => unmatched row
   7782 	clark             2450         10
   9999	vijay	   2000	     null	=> unmatche row

 => outer join is 3 types 

 1  left outer join 
 2  right  outer join
 3  full outer join

  LEFT OUTER JOIN :- 
  ------------------------------

 => returns all rows (matched + unmatched)  from left side table  
      and matching rows from right side table.

   SELECT  e.ename,NVL(d.dname,'Not Assigned') as dname
   FROM emp e  LEFT OUTER JOIN dept d
   ON e.deptno = d.deptno ; 

   smith	research
   allen	sales
   ward	sales
   jones	research
   clark	accounts 
   vijay	Not Assigned    => unmatched from emp 
 
 RIGHT OUTER JOIN :- 
 ------------------------------
  
 => returns all rows (matched + unmatched) from right side table and matching
      rows from left side table.

   SELECT  NVL(e.ename,'Empty') as ename,d.dname
   FROM emp e  RIGHT OUTER JOIN dept d
   ON e.deptno = d.deptno ; 

   smith	research
   allen	sales
   ward	sales
   jones	research
   clark	accounts 
  Empty     operations  => unmatched from dept

FULL OUTER JOIN :- 
------------------------------

 => returns all rows from both tables 

   SELECT   e.ename,d.dname
   FROM emp e  FULL OUTER JOIN dept d
   ON e.deptno = d.deptno ; 

   smith	research
   allen	sales
   ward	sales
   jones	research
   clark	accounts 
   vijay	null                =>  unmatched from emp
   null        operations     =>  unmatched from dept

 Displaying only unmatched records :- 
 -------------------------------------------------

  left side table :- 
  ---------------------
 
   SELECT  e.ename, d.dname
   FROM emp e  LEFT OUTER JOIN dept d
   ON e.deptno = d.deptno 
   WHERE d.dname IS NULL ; 
 
    vijay	null 

  right side table :- 
  -------------------------

   SELECT   e.ename,d.dname
   FROM emp e  RIGHT OUTER JOIN dept d
   ON e.deptno = d.deptno
   WHERE e.ename IS NULL ; 

  null	operations

 both tables :- 
 ----------------

   SELECT   e.ename,d.dname
   FROM emp e  FULL OUTER JOIN dept d
   ON e.deptno = d.deptno 
   WHERE d.dname IS NULL
                 OR
                 e.ename IS NULL ; 

 vijay	null
  null	operations 

Ex :- 

   emp				 projects
   empno	ename	sal	projid 	 projid   name  duration  cost  client
   100			1000         1000
   101			1001         1001
   102			null           1002

  1  display employee details with project details ?

  2  display employee details with project details 
      and also dislay employees not assigned to any project ?

  3  display only the projects where no employee assigned to it ?

   GROUP BY & JOIN :- 
   ----------------------------

  SELECT columns
  FROM tab1 JOIN tab2
  ON join cond
  [WHERE cond]
  GROUP BY  col1,----
  [HAVING cond]
  [ORDER BY ----] ;

 => display dept wise no of employees ?
      display dept names ?

      SELECT  d.dname,COUNT(e.empno)  as no_of_emps
      FROM emp e INNER JOIN dept d
      ON e.deptno = d.deptno
      GROUP BY d.dname ;

  FROM :- 
  ------------
 
   EMP				 	DEPT
  empno	ename	    sal	 deptno		deptno	dname		loc
   7369 	smith             800          20		10	ACCOUNTS	NEW YORK
   7499 	allen             1600         30		20	RESEARCH
   7521	 ward            1250         30		30	SALES
   7566 	jones            2975         20		40	OPERATIONS  => unmatched row
   7782 	clark             2450         10
   9999	vijay	   2000	     null	=> unmatche row

 ON e.deptno = d.deptno :- 
 ------------------------------------

 7369 	smith             800 	RESEARCH
 7499 	allen             1600   	SALES
 7521	 ward            1250  	SALES 
 7566 	jones            2975     RESEARCH
 7782 	clark             2450  	ACCOUNTS

   GROUP BY d.dname :- 
   ------------------------------

  ACCOUNTS	 7782 	clark             2450 
	
  RESEARCH	7369 	smith             800
		 7566 	jones            2975  

   SALES		7499 	allen             1600    
		7521	 ward            1250  	 

  SELECT  d.dname,COUNT(e.empno)  as no_of_emps :- 
  ---------------------------------------------------------------------------

    ACCOUNTS	1
   RESEARCH	2
   SALES		2

  => display dept wise no of employees ?
       display dept names ?
       display dept where no employees working ?

      SELECT  d.dname,COUNT(e.empno)  as no_of_emps
      FROM emp e RIGHT OUTER JOIN dept d
      ON e.deptno = d.deptno
      GROUP BY d.dname ;

   ACCOUNTS	1
   RESEARCH	2
   SALES		2
   OPERATIONS	0

10-nov-25 

Non Equi Join :- 
----------------------

 => non equi join is performed between the tables not sharing a common field
 => this join is called  non equi join because here join condition is not based on "=" operator

 Ex :- 
 
   EMP					SALGRADE	 	 
  empno	ename	    sal	 deptno		grade	losal	hisal	 
   7369 	smith             800          20		1	700	1000		 
   7499 	allen             1600         30		2	1001	2000			 
   7521	 ward            1250         30		3	2001	3000	 		
   7566 	jones            2975         20	                 4	3001	4000
   7782 	clark             2450         10		5	4001	9999
    
 => display  ename	sal     grade   ?
                    --------------      ---------
                         emp            salgrade
  
  SELECT e.ename,e.sal,s.grade
  FROM emp e INNER JOIN salgrade s 
  ON  e.sal BETWEEN s.losal AND s.hisal

	smith	800	1
	allen	1600	2
	ward	1250	2
 	jones	2975	3
	clarks	2450	3

=> display grade 3 employees list ? 

    SELECT e.ename,e.sal,s.grade
    FROM emp e INNER JOIN salgrade s 
    ON  e.sal BETWEEN s.losal AND s.hisal
    WHERE s.grade = 3 ; 

 => display grade wise no of employees ?

 SELECT s.grade,COUNT(e.ename) as cnt
 FROM emp e INNER JOIN salgrade s
 ON e.sal BETWEEN s.losal AND s.hisal
 GROUP BY s.grade ; 

=> display  ENAME	  DNAME	   GRADE   ? 

    SELECT e.ename,
                   d.dname,
                   s.grade
    FROM emp e INNER JOIN dept d
    ON e.deptno = d.deptno
   	         INNER JOIN salgrade s
    ON e.sal BETWEEN s.losal AND s.hisal ;

 on e.deptno = d.deptno :- 
 ---------------------------------

  EMP				 	DEPT
  empno	ename	    sal	 deptno		deptno	dname		loc
   7369 	smith             800          20		10	ACCOUNTS	NEW YORK
   7499 	allen             1600         30		20	RESEARCH
   7521	 ward            1250         30		30	SALES
   7566 	jones            2975         20		40	OPERATIONS  => unmatched row
   7782 	clark             2450         10
    
					SALGRADE
  R1					grade	losal	hisal
  7369 	smith             800    	RESEARCH	1	700	1000
  7499 	allen             1600    SALES		2	1001	2000
  7521	 ward            1250    SALES		3	2001	3000
  7566 	jones            2975    RESEARCH	4	3001	4000
  7782 	clark             2450    ACCOUNTS	5	4001	999

 on e.sal BETWEEN s.losal AND s.hisal :-
 --------------------------------------------------------

R2
 7369 	smith             800    	RESEARCH	1
 7499 	allen             1600    SALES		2	
 7521	 ward            1250    SALES		2 
 7566 	jones            2975    RESEARCH	3
 7782 	clark             2450    ACCOUNTS	3

 SELECT  e.ename,d.dname,s.grade :- 
 ------------------------------------------------------------
 
 smith	RESEARCH	1
 allen	SALES		2
 ward	SALES		2
 jones	RESEARCH	3
 clark	ACCOUNTS	3
 
 SELF JOIN :- 
 -----------------

 => joining a table to itself is called self join 
 => in self join a record in one table joined with another record of same table
 => to perform self join the same must be declared two times with different alias in FROM clause

                   FROM emp  x  INNER JOIN  emp y 

   Ex :-

   emp x				emp  y
   empno	ename	mgr		empno	ename	mgr
   7369	smith	7902		7369	smith	7902
   7499	allen	7698		7499	allen	7698
   7566	jones	7839		7566	jones	7839
   7698	blake	7839		7698	blake	7839
   7839	king	null		7839	king	null
   7902	ford	7566		7902	ford	7566

 => display  ENAME    MGRNAME   ? 

    SELECT  x.ename || ' reports to ' ||y.ename as manager
    FROM emp x INNER JOIN emp y
    ON x.mgr = y.empno ;

	smith	ford
	allen	blake
	jones	king
	blake	king
	ford	joines

 => list of employees reporting to blake ?
 
     SELECT  x.ename || ' reports to ' ||y.ename as manager
    FROM emp x INNER JOIN emp y
    ON x.mgr = y.empno  
    WHERE  y.ename='blake' ; 
	
 => blake's manager name ?

     SELECT y.ename
     FROM emp x INNER JOIN emp y
     ON x.mgr = y.empno  
     WHERE x.ename = 'blake'  ;
      
  => employees earning more than their managers ?

     SELECT x.ename,x.sal,y.ename as manager,y.sal as mgrsal
     FROM emp x INNER JOIN emp y
     ON x.mgr = y.empno  
     WHERE  x.sal > y.sal ; 
  
 => employees who are senior to their managers ?

     SELECT x.ename,x.hiredate,y.ename as manager,y.hiredate as mgrhire
     FROM emp x INNER JOIN emp y
     ON x.mgr = y.empno  
     WHERE  x.hiredate   <    y.hiredate ;
 
 => no of employees working under each manager ?

       manager		no_of_emps   ?

     SELECT  y.ename,COUNT(*) as no_of_emps
     FROM emp x INNER JOIN emp y
     ON x.mgr = y.empno  
     GROUP BY y.ename ;
    
  => display  ENAME	    DNAME      GRADE        MNAME   ? 

   SELECT e.ename,
                  d.dname,
                  s.grade,
                  m.ename as manager
  FROM emp e INNER JOIN dept d
  ON e.deptno = d.deptno
                        INNER JOIN salgrade s
  ON e.sal BETWEEN s.losal AND s.hisal
                        INNER JOIN emp m
   ON e.mgr = m.empno  ;

 LISTAGG() :- 
 -------------------

 => function used to concatenate column values 

         LISTAGG(ename,seperator) WITHIN GROUP (ORDER BY ---)

  Ex 1  :-  

     SELECT
     LISTAGG(ename,',') WITHIN GROUP (ORDER BY SAL DESC) AS NAMES
     FROM EMP ;
   
     king,ford,scott,jones,blake,clark,------

 Ex 2  :-  

   => display  dept wise employee names ? 

     SELECT deptno,
     LISTAGG(ename,',') WITHIN GROUP (ORDER BY SAL DESC) AS NAMES
     FROM EMP 
     GROUP BY deptno ;

 Question :- 

  TEAMS
   ID	COUNTRY
   1	IND
   2	AUS
   3	SA

  output :- 

  IND VS AUS
  IND VS SA
  AUS VS SA 

11-nov-25 

 CROSS JOIN / CARTESIAN JOIN :- 
 ---------------------------------------------------

 => cross join returns cross product or cartesian product of two tabels 

         A = 1,2
         B = 3,4

   AXB  = (1,3) (1,4) (2,3) (2,4) 

=> if cross join performed between two tables then all records of 1st table joined with all records
      of 2nd table.

 => To perform cross join submit the join query without join condition.
  
 Ex 1  :- 
 
SELECT e.ename,d.dname
FROM emp e CROSS JOIN dept d ;
 
Ex 2 :- 

 T1				T2
 ID	NAME	PRICE 		ID	NAME		PRICE
 1	PIZZA	120		1	THUMSUP	40
 2	BURGER	80		2	JUICE		60

output :- 

 PIZZA + THUMSUP		160
 PIZZA + JUICE		180
 BURGER + THUMSUP	120
 BURGER + JUICE		140

SELECT  T1.NAME  || ' + ' ||T2.NAME ,  T1.PRICE + T2.PRICE AS TOTAL
FROM T1 CROSS JOIN T2 

scenario :-
---------------

SALES
dateid		prodid	custid	qty	amt
11-nov-25		100	10	1	2000

products
prodid	pname	price	category
100	KKK	2000	ELECTRONICS

cust
custid	name	addr	country
10	AA	HYD	IND

 => display year wise total amount ?

   SELECT  EXTRACT(YEAR FROM dateid) as year, SUM(amount) as total
   FROM  sales
   GROUP BY EXTRACT(YEAR FROM dateid) ;

 => display category wise total amount ?

    SELECT p.category , SUM(s.amount)  as total
    FROM sales s INNER JOIN  products p
    ON  s.prodid = c.prodid 
    GROUP BY p.category ; 

 => display country wise total amount ?

   SELECT c.country , SUM(s.amount) as total
   FROM sales s INNER JOIN cust c 
   ON s.custid = c.custid 
   GROUP BY  c.country 


 => display year wise , country wise , category wise total amount ?

    SELECT EXTRACT(year from s.dateid) as year,
                   c.country,
                   p.category, SUM(s.amount) as total
    FROM   sales s INNER JOIN products p
    ON  s.prodid = p.prodid
                             INNER JOIN cust c
    ON s.custid  = c.custid
    GROUP BY EXTRACT(year from s.dateid) , c.country , p.category 
    ORDER BY  year ASC  ; 

Natural join :- 
-------------------

 => Natural join is performed between the two tables based on the common field with same name

 emp				dept
 empno	ename	deptno		deptno	dname	loc


 SELECT e.ename,d.dname
 FROM emp e NATURAL JOIN dept d ; 
 
=> above query performs equi join between emp & dept based on deptno 

==========================================================================

SET OPERATORS :- 
---------------------------

 UNION
 UNION ALL
 INTERSECT
 MINUS 

 A = 1,2,3,4
 B =1,2,5,6

A   UNION   B	=>      1,2,3,4,5.6 
A   UNION ALL B	=>      1,2,3,4,1,2,5,6
A   INTERSECT B	=>      1,2
A   MINUS  B	=>      3,4
B   MINUS  A	=>      5,6

=> In ORACLE  set operations performed between the rows return by two queries

   SELECT  statement 1 
   UNION / UNION ALL / INTERSECT / MINUS
   SELECT statement 2 ; 

  Rules :- 
  -----------

 1  no of columns return by both queries must be same
 2  corresponding columns datatype must be same

  Query 1 :- 
  ------------------

 SELECT job FROM emp WHERE deptno = 20 ;

CLERK
MANAGER
ANALYST
CLERK
ANALYST

Query 2 :- 
---------------

 SELECT job FROM emp WHERE deptno = 30 ; 

SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

UNION :- 
---------------

 => combines rows return by two queries
 => duplicates are eliminated
 => result is sorted

 SELECT job FROM emp WHERE deptno = 20 
 UNION
 SELECT job FROM emp WHERE deptno = 30 ; 

ANALYST
CLERK
MANAGER
SALESMAN
 
 SELECT job,sal FROM emp WHERE deptno = 20 
 UNION
 SELECT job,sal FROM emp WHERE deptno = 30 ; 

 JOB              	SAL
--------- 		----------
ANALYST         	3000
CLERK            	800
CLERK           	 950
CLERK           	1100
MANAGER        	 2850
MANAGER        	 2975
SALESMAN       	 1250
SALESMAN       	 1500
SALESMAN       	 1600
 
 => difference between UNION & JOIN  ?

      	union				join 

1	combines rows			combines columns 

2	horizontal merge			vertical merge

3	performed between 			performed between two tables 
                two query outputs

 Ex 1 :-  

T1	T2
F1	C1
1	10
2	20
3	30

UNION :- 			JOIN  :-
---------------		-----------

1			1	10
2			2	20
3			3	30
10
20
30

Ex 2 :- 

 EMP_US
 ENO	ENAME	DNO
 100		10
 101		20
					DEPT
 EMP_IND				DNO	DNAME	LOC
 ENO	ENAME	DNO			10	HR
200		10			20	IT
201		30			30	SALES


=> total employees list ? 

  SELECT * FROM EMP_US
  UNION
  SELECT * FROM EMP_IND  ; 

=> employees working at US loc with dept details ?
   
   SELECT e.* , d.* 
   FROM emp_us e INNER JOIN dept d
   ON e.dno = d.dno  ; 

=> total employee list with dept details ? 

   SELECT e.* , d.* 
   FROM emp_us e INNER JOIN dept d
   ON e.dno = d.dno 
   UNION 
   SELECT e.* , d.* 
   FROM emp_ind e INNER JOIN dept d
   ON e.dno = d.dno  ; 
 
    SELECT *
    FROM   (SELECT * FROM emp_us
                   UNION
                   SELECT * FROM emp_ind)   e   INNER JOIN  dept d 
    ON e.dno = d.dno  ;
    
UNION ALL :- 
------------------

 => combines rows return by two queries
 => duplicates are not eliminated
 => result is not sorted 

 SELECT job FROM emp WHERE deptno = 20 
 UNION ALL
 SELECT job FROM emp WHERE deptno = 30 ; 

CLERK
MANAGER
ANALYST
CLERK
ANALYST
SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

 difference between UNION & UNION ALL ?

	UNION			UNION ALL

1	eliminates duplicates	doesn't eliminate duplicates 

2	result is sorted		result is not sorted 

3	slower			faster

 
INTERSECT :- 
-------------------

=> returns common values from the output of two select stmts 

  SELECT job FROM emp WHERE deptno = 20 
  INTERSECT
  SELECT job FROM emp WHERE deptno = 30 ; 

 CLERK
 MANAGER

MINUS :- 
-------------

 => returns values present in 1st query output and not present in 2nd query output

  SELECT job FROM emp WHERE deptno = 20 
  MINUS
  SELECT job FROM emp WHERE deptno = 30 ; 

  ANALYST

   SELECT job FROM emp WHERE deptno = 30 
  MINUS
  SELECT job FROM emp WHERE deptno = 20 ; 

  SALESMAN 

 
 Question 1  :- 
 ---------------- 
 
T1		T2
F1		F1
1		1
2		2
3		3
10		40
20		50
30		60

=> write the output for following operations ? 

 1 EQUI JOIN
 2  LEFT OUTER JOIN
 3  RIGHT OUTER JOIN
 4  FULL OUTER JOIN
 5  UNION
 6  UNION ALL
 7  INTERSECT
 8  MINUS

Question 2 :- 

 T1			T2
 F1			F1
 1			1
 2			2
 1			1
 2			2
 NULL			NULL
 NULL			NULL

 => no of rows return by each operation  ? 

 EQUI JOIN		=>	8
 LEFT OUTER JOIN		=>	10	
 RIGHT OUTER JOIN	=>	10
 FULL OUTER JOIN 		=>	12
 UNION			=>	2
 UNION ALL		=>	12
 INTERSECT		=>	2
 MINUS			=>	0
 
12-NOV-25 

SUB-QUERIES / NESTED QUERIES :- 
==============================

 => a query in another query is called sub-query or nested query
 => one query is called  inner / child / sub - query
 => other query is called outer / parent / main query
 => first oracle executes inner next it executes outer query
 => output of inner query is input to outer query
 => use sub-query when where cond based on unknown value

  Types of sub-queries :- 
  ---------------------------------

 1  Non Co-related sub-queries 
             single row sub-queries
             multi row sub-queries 
  2  Co-related sub-queries
  3  INLINE views and CTEs
  4  scalar sub-queries

 single row  sub-queries :- 
 -----------------------------------

 => if inner query returns one value then it is called single row sub-query

   SELECT columns
   FROM tabname
   WHERE colname OP (SELECT statement)  ; 

 => sub-query output acts like a value for where cond
 => OP must be any relational operator like  =   >    <     <> 

Ex :- 

 => employees earning more than blake ?

  SELECT *
  FROM emp
  WHERE sal >  (SELECT sal FROM emp WHERE ename='blake') ; 
	          ------------------------------------------------------------------
			2850

=> employees who are senior to king ?

   SELECT *
   FROM emp 
   WHERE hiredate  < (SELECT hiredate FROM emp WHERE ename='king') ; 
		   ---------------------------------------------------------------------			
			17-NOV-81

 => name of the employee earning max salary ? 

      SELECT ename
      FROM emp 
      WHERE sal = MAX(sal) ;    => ERROR

      SELECT ename,MAX(sal)
      FROM emp ;                        => ERROR

      SELECT ename
      FROM emp 
      WHERE sal = (SELECT MAX(sal) FROM emp) ; 
	              -------------------------------------------
			5000
       
 => name of the employee having max experience ?

      SELECT ename
      FROM emp 
      WHERE hiredate = (SELECT MIN(hiredate) FROM emp);
		     ------------------------------------------------	
			17-dec-80

 => names of the employees having min,max experience ?

      SELECT ename
      FROM emp 
      WHERE hiredate = (SELECT MIN(hiredate) FROM emp) 
                     OR
                    hiredate = (SELECT MAX(hiredate) FROM emp) ;

      SELECT ename
      FROM emp 
      WHERE hiredate = (SELECT MIN(hiredate) FROM emp) 
      union
     SELECT ename
      FROM emp 
      WHERE hiredate = (SELECT MAX(hiredate) FROM emp) 

 => display 2nd max salary ?

    SAL
    5000
    1000
    3000
    2000
    2500

  SELECT MAX(sal) 
  FROM emp 
  WHERE sal  <> (SELECT MAX(sal) FROM emp) ;

=> name of the employee earning 2nd max salary ?

    SELECT ename,sal
    FROM emp 
    WHERE sal =   (SELECT MAX(sal) 
                              FROM emp 
                              WHERE sal  <> (SELECT MAX(sal) FROM emp)); 
                                                          ----------------------------------------
				   5000
                               ----------------------------------------------------------------
			3000

=> employees working at NEW YORK loc ?
 
sub-query :-
------------------

 SELECT *
 FROM emp 
 WHERE deptno = (SELECT deptno 
                                FROM dept
                                WHERE loc='NEW YORK') ; 
 
join :-
-----------

SELECT e.*
FROM emp e INNER JOIN dept d
ON e.deptno = d.deptno
WHERE d.loc ='NEW YORK' ; 

 => display employee details with dept details working at NEW YORK loc ?

join :-
-----------

SELECT e.ename,d.dname,d.loc
FROM emp e INNER JOIN dept d
ON e.deptno = d.deptno
WHERE d.loc ='NEW YORK' ; 

sub-query :- 
-----------------

 not possible

 difference between sub-query and join ?

  1  to display data from one table and condition based on another table then
      we can use sub-query or join

 2   to display data from two tables then use join .

 => incr sal by 10% of the employee having max experience ?

     UPDATE emp 
     SET sal = sal + (sal*0.1)
     WHERE hiredate = (SELECT MIN(hiredate) FROM emp) ;

 => swap employee salaries whose empno = 7369,7499 ?

      before swap		after swap
     
      7369    800		7369	1600
      7499    1600		7499	800

   UPDATE emp 
   SET sal =  CASE empno
                     WHEN 7369 THEN  (SELECT sal FROM emp WHERE empno=7499)
                     WHEN 7499 THEN (SELECT sal FROM emp WHERE empno=7369)
                      END
  WHERE empno IN (7369,7499) ; 

 => delete employee having max experience ? 

    DELETE 
    FROM emp 
    WHERE hiredate = (SELECT MIN(hiredate) FROM emp) ;
 
=> display dept having max no of employees ? 

     SELECT DEPTNO
     FROM EMP
     GROUP BY DEPTNO
      HAVING COUNT(*)  = (SELECT MAX(COUNT(*))
                                           FROM EMP
                                           GROUP BY DEPTNO);

=>  display in which year max no of employees joined ? 

  SELECT EXTRACT(year from hiredate) as year
  FROM emp 
  GROUP BY EXTRACT(year from hiredate)
  HAVING COUNT(*) = (SELECT  MAX(COUNT(*))
                                      FROM emp 
                                      GROUP BY EXTRACT(year from hiredate)); 

 Multi-row sub-queries :- 
 -------------------------------- 

=> if inner query returns more than one value then it is called multi row sub-query

    SELECT columns
    FROM tabname
    WHERE colname OP (SELECT statement); 

 => OP must be IN,NOT IN,ANY,ALL 

	  single			multi

	   =			IN

	   <>			NOT IN

	   >			>ANY   >ALL

                    <                                            <ANY    <ALL

Ex :- 

=> employees working at NEW YORK,CHICAGO locations ? 

     SELECT *
     FROM emp 
     WHERE deptno IN (SELECT deptno 
                                    FROM dept
                                    WHERE loc IN ('NEW YORK','CHICAGO')) ;

 ANY,ALL operators :- 
 ----------------------------

 => use ANY , ALL  for  >   <  comparision with multiple values 

   WHERE sal > ANY(1000,2000,3000)         WHERE sal < ANY(1000,2000,3000)
 
   IF sal = 800     FALSE		     IF  sal =   800   TRUE
               1500    TRUE                                                  1500  TRUE
               4000    TRUE                                                  4000  FALSE
  

 WHERE sal > ALL(1000,2000,3000)          WHERE sal < ALL(1000,2000,3000)
 
  IF  sal = 800   FALSE		      IF sal = 800  TRUE
               1500  FALSE                                                 1500 FALSE
                4000  TRUE                                                  4000 FALSE

=> employees who are earning more than all managers ?

   SELECT *
   FROM emp 
   WHERE sal  > ALL (SELECT sal FROM emp WHERE job='MANAGER'); 
		 -------------------------------------------------------------------
			 2975
     			 2850
     			 2450	

13-nov-25

 co-related sub-queries :- 
-----------------------------------

=> if inner query references values of outer query then it is called co-related sub-query

=> execution starts from outer query and inner query is executed no of times depends
     on no of rows return by outer query.

=> use co-related sub-query to execute sub-query for each row return by outer query

execution :- 
------------------

1 returns a row from outer query
2 pass value to inner query
3 executes inner query
4 pass inner query output to outer query
5 executes outer query where cond

 Ex :- 

 emp
 empno	ename	sal	deptno 
1	A	5000	10
2	B	3000	20
3	C	4000	30
4	D	6000	20
5	E	3000	10

=> find employees earning more than avg sal of the organization ? 

  SELECT *
  FROM emp 
  WHERE sal >  (SELECT AVG(sal) FROM emp) ; 
                           ------------------------------------------
		   4200

=> find employees earning more than avg sal of their dept ? 

   SELECT *
   FROM emp  e
   WHERE sal >  (SELECT AVG(sal) FROM emp  WHERE deptno = e.deptno) ; 

 emp
 empno	ename	sal	deptno 
1	A	5000	10           5000 > (where deptno = 10)   4000      TRUE
2	B	3000	20           3000 >  (where deptno=20)    4500      FALSE
3	C	4000	30           4000 > (where deptno=30)     4000      FALSE
4	D	6000	20           6000 > (where deptno=20)     4500      TRUE
5	E	3000	10           3000 > (where deptno=10)     4000       FALSE


=> employees earning max salary in their dept ? 

  SELECT *
  FROM emp  e
  WHERE sal =  (SELECT MAX(sal) FROM emp WHERE deptno = e.deptno) ; 

 emp
 empno	ename	sal	deptno 
1	A	5000	10        5000 = (5000)     TRUE
2	B	3000	20        3000 = (6000)     FALSE
3	C	4000	30        4000 = (4000)      TRUE
4	D	6000	20        6000 = (6000)      TRUE
5	E	3000	10        3000 = (5000)      FALSE

=> display top 3 max salaries ? 
  
      SELECT  DISTINCT a.sal
      FROM emp a
      WHERE 3  > (SELECT COUNT(DISTINCT b.sal)
                             FROM emp b
                             WHERE a.sal < b.sal) 
     ORDER BY a.sal DESC ; 

 EMP a		EMP b
 SAL		SAL
 5000		5000             3 > (0)	 TRUE
 1000		1000             3 > (4)	  FALSE
 3000		3000             3 > (1)    TRUE
 2000		2000             3 > (3)     FALSE
 2975		2975             3 > (2)     TRUE


 => display 3rd max salary  ? 

      SELECT  DISTINCT a.sal
      FROM emp a
      WHERE (3-1) =  (SELECT COUNT(DISTINCT b.sal)
                                   FROM emp b
                                   WHERE a.sal < b.sal) 
     ORDER BY a.sal DESC ; 
 
 => display Nth max salary ? 

      SELECT  DISTINCT a.sal
      FROM emp a
      WHERE (&N-1) =  (SELECT COUNT(DISTINCT b.sal)
                                     FROM emp b
                                     WHERE a.sal < b.sal) 
      ORDER BY a.sal DESC ; 
 
 ROWID :- 
 ---------------

 => rowid is a psuedo column because it is not a column but acts like a column 
 => rowid returns physical address of a row i.e. where the record is stored in memory
 
      SELECT rowid,empno,ename,sal FROM emp ; 

      AAAeNjAAHAAAA5GAAA       7369 smith             800

 => rowids are used to delete duplicate rows from table 

Ex :- 

 EMP44
 ENO	ENAME	SAL 	ROWID
 1	A	5000	AAA
 2	B	6000	AAB
 3	C	7000	AAC	
 1	A	5000	AAD
 2	B	6000	AAE

  DELETE FROM emp44 WHERE rowid LIKE '%AAD' ;
  DELETE FROM emp44 WHERE rowid LIKE '%AAE' ;

 deleting duplicates row-by-row is difficulat if table contains lakhs of duplicate rows , so 
 execute the following query to delete all duplicate rows 

Method 1 :-   (using co-related sub-query)

 DELETE
 FROM emp44 a
 WHERE rowid  <>  (SELECT MIN(rowid)
                                 FROM emp44
                                 WHERE eno = a.eno
                                                AND
                                                ename=a.ename
                                                AND
                                                 sal = a.sal) ;

EMP44
 ENO	ENAME	SAL 	ROWID
 1	A	5000	AAA       <>   (AAA)      FALSE
 2	B	6000	AAB       <>   (AAB)      FALSE
 3	C	7000	AAC       <>  (AAC)       FALSE	 
 1	A	5000	AAD       <>  (AAA)       TRUE
 2	B	6000	AAE       <>   (AAB)      TRUE

 Method 2 :-  (not using co-related sub-query)

 DELETE  
 FROM emp44
 WHERE rowid NOT IN (SELECT MIN(rowid)
                                      FROM emp44
                                      GROUP BY eno,ename,sal) ;

			AAA
	 		AAB
			AAC

 EMP44
 ENO	ENAME	SAL 	ROWID
 1	A	5000	AAA       
 2	B	6000	AAB       
 3	C	7000	AAC        
 1	A	5000	AAD       
 2	B	6000	AAE        

14-nov-25 

INLINE views :-
---------------------

 =>  sub-queries in FROM clause are called inline views or derived tables

   SELECT columns
   FROM (SELECT statement)  <ALIAS>
   WHERE condition ;

 => sub-query output acts like a table for outer query
 => INLINE views are used in following scenarios

  1 to control order of execution of clauses 
  2 to use result of one operation in another operation
  3 to join two query outputs 

 controlling order of execution of clauses :- 
 ----------------------------------------------------------

Default order :- 
---------------------

FROM
WHERE
GROUP BY 
HAVING
SELECT
ORDER BY 

 => To control this order of execution use INLINE views 

 SELECT					SELECT
 FROM   ------------------------------------------------------->   FROM (SELECT
 WHERE                                                                                  FROM
 ORDER BY                                                                             ORDER BY ) 
                                                                                     WHERE
 
Ex 1 :- 

 => display ranks of the employees based on sal and highest paid should get 1st rank ?

     SELECT empno,ename,sal,
                   DENSE_RANK() OVER (ORDER BY sal DESC) as rnk
     FROM emp ; 

    above query displays ranks of all the employees but to display top 5 employees

     SELECT empno,ename,sal,
                   DENSE_RANK() OVER (ORDER BY sal DESC) as rnk
     FROM emp  
     WHERE rnk <= 5 ;   => ERROR

     column alias cannot be used in where clause because where clause is executed
     before select , to overcome this use INLINE views

     SELECT *
     FROM (  SELECT empno,ename,sal,
                            DENSE_RANK() OVER (ORDER BY sal DESC) as rnk
                  FROM emp )  E
     WHERE rnk <= 5 
 
 =>  display top 3 max salaries ?

     SELECT DISTINCT sal
     FROM (  SELECT  sal,
                            DENSE_RANK() OVER (ORDER BY sal DESC) as rnk
                  FROM emp )  E
     WHERE rnk <= 3; 

  => display 5th max salary ? 

     SELECT DISTINCT sal
     FROM (  SELECT  sal,
                            DENSE_RANK() OVER (ORDER BY sal DESC) as rnk
                  FROM emp )  E
     WHERE rnk = 5 ; 

 => display top 3 max salaries in each dept ? 

 step 1 :-  find ranks of the employees with in dept based on sal 

  SELECT   deptno,sal,
                   DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) as rnk
  FROM emp ; 

   DEPTNO       	 SAL        RNK
    ---------- 	---------- ----------
        10       	5000          1
                 	2450          2
                		300            3

        20       	3000          1
                 	3000          1
                 	2975          2
                 	1100          3
                 	 800           4

        30       	2850          1
                 	1600          2
                 	1500          3
                 	1250          4
                 	1250          4
                		  950          5

 step 2 :-  To display top 3 select rank upto 3 
 
  SELECT   DISTINCT deptno,sal,rnk
   FROM ( SELECT   deptno,sal,
                   DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) as rnk
           FROM emp )  E
  WHERE rnk <= 3 
  ORDER BY deptno ASC ; 

 
ROWNUM :- 
-----------------

 => rownum generates row numbers i.e. record numbers
 => used to display records with record number
 => rownum is also a psuedo column because it is not a column but acts like a column 

  Ex :-    SELECT rownum,empno,ename,sal FROM emp ; 

	9	7839	KING	5000

           SELECT rownum,empno,ename,sal FROM emp  WHERE sal>=2000;
 
	  5       	7839 	king             5000

           SELECT rownum,empno,ename,sal FROM emp WHERE sal>=3000;

	  2       7839	 king             5000

 note :- 

  => rownum is not based on table , it is based on query output , if query output changes
       rownum also changes.

 => display first 5 rows from emp table ? 

      SELECT  rownum,empno,ename,sal 
      FROM emp 
      WHERE  rownum <= 5 ; 
       
 => display 5th row from emp ? 

      SELECT  rownum,empno,ename,sal 
      FROM emp 
      WHERE  rownum = 5 ;      => NO ROWS 

   with rownum in where conditions we cannot use   =    >  only   <   <=  can be used , to 
   overcome this use INLINE views.

    SELECT *
    FROM ( SELECT  rownum as rno,empno,ename,sal 
                  FROM emp ) E
    WHERE rno = 5 ; 
  
    WHERE rno IN (5,10,15);

    WHERE rno BETWEEN 5 AND 10 ;

    WHERE MOD(rno,2) = 0 

  => display last 3 rows from emp ?

    SELECT *
    FROM ( SELECT  rownum as rno,empno,ename,sal 
                  FROM emp ) E
    WHERE rno >=  (SELECT COUNT(*)-2  FROM emp) ; 

  CTE  :-    
  -----------

  => CTE stands for common table expression
  => CTE is alternative to INLINE view
  => using CTE also we can give name to the query output and we can use that in another query
  => using CTE we can simplify complex scenarios

WITH <CTE1-NAME>
AS
   (SELECT STATEMENT) , 

  <CTE2-NAME>
 AS
    (SELECT STATEMENT)

  SELECT  statement ;

Ex 1 :- 

 WITH E
  AS
    (SELECT rownum as rno,empno,ename,sal FROM emp) 
  SELECT * FROM E where rno = 5;

Ex 2 :- 

 T1		T2
 F1		F1
 10		A
 20		B
 30		C

output :- 
 
10	A
20	B
30	C

Query 1 :- 

 SELECT ROWNUM as rno ,F1 FROM T1 ; 

 
       RNO         F1
---------- ----------
         1         10
         2         20
         3         30

Query 2 :- 

  SELECT ROWNUM as rno,F1 FROM T2 ; 

   RNO F
---------- -
         1 A
         2 B
         3 C

 WITH  A 
  AS
     ( SELECT ROWNUM as rno ,F1 FROM T1) ,
   B
   AS
      (SELECT ROWNUM as rno,F1 FROM T2)
   SELECT  A.F1,B.F1
   FROM A INNER JOIN B
  ON A.RNO = B.RNO  ;
 
A			B
RNO	F1		RNO	F1
1	10		1	A
2	20		2	B
3	30		3	C

Ex 3 :- 

T1
AMT
5000
-300
4000
-200
3000
-500

 output :- 
 
 POS			NEG
 5000			-300
 4000			-200
 3000			-500

 Query 1 :- 

 SELECT ROWNUM as rno,AMT FROM T1 WHERE AMT > 0 ; 

      1	5000
      2	4000
      3	3000

Query 2 :- 

 SELECT ROWNUM as rno,AMT FROM T1 WHERE AMT < 0 ;
	

    1  -300
    2  -200
    3  -500
 
WITH P
 AS
   ( SELECT ROWNUM as rno,AMT FROM T1 WHERE AMT > 0) ,
 N
 AS
  (SELECT ROWNUM as rno,AMT FROM T1 WHERE AMT < 0 )
 SELECT P.AMT , N.AMT
 FROM P INNER JOIN N
 ON P.RNO = N.RNO ; 

Ex 4 :- 
  
 CRICKET
  TEAMA		TEAMB		WINNER
  ENGLAND	NEW ZEALAND	NEW ZEALAND

  country		played		won		lost 


17-nov-25 

scalar sub-queries :- 
---------------------------

=> sub-queries in SELECT clause are called scalar sub-queries

     SELECT (select stmt1) , (select stmt2), ----------
     FROM tabname
     WHERE cond

 => sub-query output acts like a column 
 => use scalar sub-query to show the query output in seperate column

 Ex 1  :- 

  SELECT  (SELECT COUNT(*) FROM emp)  AS EMP, 
                  (SELECT COUNT(*) FROM dept)  AS DEPT
  FROM DUAL ; 

   EMP       DEPT
 ----------     ----------
        14          4
 
Ex 2 :- 

 => dislay dept wise total salary ?

   SELECT deptno,SUM(sal) as dept_totsal
   FROM emp
   GROUP BY deptno ;

 DEPTNO   SUM(SAL)
---------- 	  ----------
        30       9400
        10       8750
        20      10875

 => display  DEPTNO	DEPT_TOTSAL		TOTSAL	 ?

    SELECT deptno,SUM(sal) as dept_totsal ,
                   (SELECT SUM(sal) FROM emp) as totsal
   FROM emp
   GROUP BY deptno ;

    DEPTNO DEPT_TOTSAL     TOTSAL
    ----------     -----------------           ----------
        30        9400     	 	29025
        10        8750      	29025
        20       10875      	29025

=> display  DEPTNO	DEPT_TOTSAL	 TOTSAL	      	PCT   ? 

 	PCT =   ( DEPT_TOTSAL / TOTSAL )*100

  
    SELECT deptno,SUM(sal) as dept_totsal ,
                   (SELECT SUM(sal) FROM emp) as totsal ,
                  ROUND( (SUM(sal) / (SELECT SUM(sal) FROM emp))*100,1) as pct
   FROM emp
   GROUP BY deptno ;


 WITH E
  AS
    (
          SELECT deptno,SUM(sal) as dept_totsal,
                         (SELECT SUM(sal) FROM emp) as totsal
          FROM emp 
          GROUP BY deptno
     )
   SELECT deptno,dept_totsal,totsal,(dept_totsal/totsal)*100 as pct 
   FROM E ;

 ========================================================================

 PIVOT operator :- 
 ------------------------

 => operator used to convert rows into columns 
 => operator used for cross tabulation
 => operator used to display data in matrix form

 SELECT columns
 FROM (SELECT required data) <alias>
 PIVOT
 (
    AGGR-EXPR FOR colname IN (v1,v2,v3,---)
 ) 
ORDER BY col ASC/DESC ; 

Ex 1 :- 

			10	20	30
	
	analyst		?	2000	?

	clerk

	manager

	president

	salesman				5600

 SELECT *
 FROM (SELECT deptno,job,sal FROM emp)  E
 PIVOT
 (
    SUM(sal) FOR  deptno IN (10,20,30)
  )
 ORDER BY job ASC ; 

Ex 2  :- 

 			1	2	3	4

		1980	?	?	?	?

		1981

		1982

		1983

  SELECT *
  FROM (SELECT TO_CHAR(hiredate,'yyyy') as year ,
                              TO_CHAR(hiredate,'q') as qrt,
                              empno
             FROM emp)  E
  PIVOT
  (
      COUNT(empno) FOR qrt IN (1,2,3,4)
  )
  ORDER BY year ASC ; 

Ex 3 :- 

 STUDENT
 sno	sname	subject	marks
 1	A	MAT	80
 1	A	PHY	60
 1	A	CHE	50
 2	B	MAT	50
 2	B	PHY	60
 2	B	CHE	40

 output :-

 sno	sname	mat	phy	che
 1	A	80	60	50
 
How to create new table from existing table (replica)  :- 
==========================================

 CREATE TABLE <new-tabname>
 AS
 SELECT columns
 FROM <old-tabname>
 [WHERE --] ;

Ex 1 :- copying complete table
 
 CREATE TABLE emp20 
 AS
 SELECT * FROM emp ;

 => all the rows and columns of emp table copied to emp20

Ex 2 :-  copying specific rows & cols 

CREATE TABLE emp21
AS
SELECT empno,ename,job,sal
FROM emp
WHERE job IN ('CLERK','MANAGER') ; 


Ex 3 :-  copy only structure (cols) but not data  (rows)

CREATE TABLE emp22
AS
SELECT * FROM emp WHERE 1=2; 

 Ex 4 :-  copying table from one user to another user

   copy emp table from  user BATCH53 to  user VIJAY  ?

  USERNAME :- SYSTEM/TIGER

  SQL>CREATE TABLE  VIJAY.emp
            AS
            SELECT * FROM BATCH53.emp ; 
 
 copying data from one table to another table :- 
 ----------------------------------------------------------------

  INSERT INTO <target-table> 
  SELECT column FROM <source-table> [WHERE cond] ; 

 Ex :-  copy data from emp table emp22 ?

   INSERT INTO emp22
   SELECT * FROM emp ; 

 MERGE command :- 
 ----------------------------

=> command used to merge data into a table
=> merge is the combination of insert & update
=> using merge command we can apply changes made to one table to another table

 MERGE INTO <target-table>
 USING <source-table>
 ON (condition)
 WHEN MATCHED THEN
         update ;
 WHEN NOT MATCHED THEN
         insert ;

Ex :- 

step 1 :-  create source table 

 CREATE TABLE custs 
 (
  cid NUMBER(2),
  cname VARCHAR2(10),
  city  VARCHAR2(10)
 );

INSERT INTO custs VALUES(10,'A','HYD') ; 
INSERT INTO custs VALUES(11,'B','BLR') ; 

step 2 :- create replica

 CREATE TABLE custt
 AS
 SELECT * FROM custs ;

SELECT * FROM custs ; 			SELECT * FROM custt ;

 CID	CNAME	CITY			CID	CNAME	CITY
 10	A	HYD 			10	A	HYD
 11	B	BLR			11	B	BLR

step 3 :-  modify source table data 

INSERT INTO custs VALUES(12,'C','DEL') ; 

 UPDATE custs SET city='MUM' WHERE cid=10 ;

 SELECT * FROM custs ;			SELECT * FROM custt ;

 cid	cname	city			cid	cname	city
 10	A	MUM => U		10	A	HYD
 11	B	BLR			11	B	BLR
 12	C	DEL => I			

step 4 :- apply changes made to custs to custt 

 MERGE INTO custt  t
 USING custs s
 ON (s.cid = t.cid)
  WHEN MATCHED THEN
    UPDATE SET t.city = s.city 
  WHEN NOT MATCHED THEN
     INSERT  VALUES(s.cid,s.cname,s.city) ;
 
18-nov-25 

Database Transactions :- 
-----------------------------------

 => a transaction is a unit of work that contains one or more dml operations and
       must be saved as a whole or must be cancelled as a whole.

 ex :-   acct1-------------------------1000----------------------------------->acct2
          
           update1					update2
           (bal = bal - 1000)				(bal = bal + 1000)

           successful					failed		invalid

 
           failed					successful	invalid

           succcessful					successful	valid

           failed					failed		valid

  => every transaction must gurantee a property called atomocity i.e. all or none
       if transaction contains multiple operations , if all are successful then it must be
       saved , if one of the operation fails then entire transaction must be cancelled.

 =>  the following commands provided by oracle to control transactions are called TCL
       commands

      1  COMMIT		=> To save transaction
      2  ROLLBACK		=>  To cancel transaction
      3  SAVEPOINT		=>  To cancel part of the transaction

 => every transaction has a begin point and end point
 => in oracle a txn begins implicitly with dml command  
 => a txn ends when any of the following command is executed 

   1  COMMIT / ROLLBACK
   2  DDL command (txn ends with commit)

 Ex  :- 

 create table a(a  number(2));    /* implicitly committed */
 insert into a values(10);           /*  transaction begins T1 */ 
 insert into a values(20);
 insert into a values(30);
 insert into a values(40);
 rollback ;                                  /*  transaction ends */ 

  => if txn ends with rollback then it is called aborted txn and operations are cancelled

 create table a(a  number(2));    /* implicitly committed */
 insert into a values(10);           /*  transaction begins t1 */     
 insert into a values(20);
 commit ;                                   /* transaction ends */
 insert into a values(30);           /* transaction begins t2 */
 insert into a values(40);
 rollback ;                                  /* transaction ends */ 

    => if txn ends with commit then it is called successful transaction and operations are saved


 create table a(a  number(2));    /* implicitly committed */
 insert into a values(10);           /* transaction begins t1 */
 insert into a values(20);
 create table b(b number(2));   /*  txn ends with commit */                        
 insert into a values(30);         /* txn begins t2 */       
 insert into a values(40);
 rollback ;                               /* txn ends */          
  	  	 	       
 SAVEPOINT :- 
 --------------------

  => we declare savepoint and we can rollback upto the savepoint 
  => using savepoint we can cancel part of the transaction

  
 create table a(a  number(2));     
 insert into a values(10);         
 insert into a values(20);  
 savepoint sp1;               
 insert into a values(30);            
 insert into a values(40);
 savepoint sp2;
 insert into a values(50);            
 insert into a values(60);
 rollback to sp1 ; 
                                
 Locking :- 
 --------------

 => accessing same data by no of users at the same time is called concurrent access
 => when data accessed concurrently then users encournters following problems 

  1 dirty read
  2 lost update
 3  phantom read
 4  non repeatable read 

 => To overcome these problems every db system supports a mechanism called locking 
     mechanism

=> locks are 2 types / modes 

 1  shared lock  (s)  => applied when we try to read data (select command)
 2  exclusive lock (x)  => applied when we try to update data (dml command)

		  S	X

	S	YES	YES


	X	YES	NO


 DeadLock :- 
------------------

 => if two users mutually waits for one another then it is called deadlock , when deadlock
      occurs then oracle throws error , so one transaction can be cancelled and continue
      another transaction.

 Locking Table :- 
 ----------------------

      LOCK TABLE <tabname> IN <mode> ;

SQL>LOCK TABLE EMP IN EXCLUSIVE MODE ; 

SQL>LOCK TABLE EMP IN SHARE MODE ; 

==========================================================================

DB Security :- 
===========

1  USERS		=>  provides security at  db level
2  PRIVILEGES        =>  provides security at table level
3  VIEWS                 =>   provides security at row & col level

  DB  (USERS)
    TABLES  (PRIVILEGES)
           ROWS & COLS  (VIEWS)

 19-nov-25 

DB objects :- 
============

1  TABLES
2  VIEWS
3  SYNONYMS
4  SEQUENCES
5  INDEXES 

VIEWS :- 
-------------

 => a  view is a subset of a table i.e part of the table.

 => a view is a virtual table because it doesn't store data and doesn't occupy memory
      and it always derives data from base table.

 => a view is representation of a query

 => views are created 

  1  to provide security
  2  to reduce complexity 

=> views are 2 types 

  1  simple views
  2  complex views 

 simple view :- 
 ---------------------

  => if view created on single table then it is called simple view

 CREATE VIEW <name>
AS
SELECT columns FROM tabname [WHERE cond] ; 

Granting permission to create view :-
---------------------------------------------------

SYSTEM :-
---------------

 SQL>GRANT CREATE VIEW TO BATCH53 ; 

BATCH53 :- 
-----------------

 CREATE VIEW V1
 AS
 SELECT empno,ename,job,deptno FROM emp ; 
 
 => oracle creates view V1 and stores query but not query output  i.e. 

    SELECT * FROM  V1 ; 

 => when above query is submitted to oracle , it executes the query as follows 

        SELECT * FROM  (SELECT empno,ename,job,deptno FROM emp);

 Granting permissions on view to user :- 
 -------------------------------------------------------

  GRANT ALL ON V1 TO NARESH ; 
 
 NARESH :- 
----------------

 1  SELECT * FROM BATCH53.V1 ; 

 2  UPDATE  BATCH53.V1 SET JOB='MANAGER'  WHERE EMPNO = 7369 ; 

 3  INSERT INTO BATCH53.V1 VALUES(100,'A','ANALYST',20);

 Row level security :- 
 ---------------------------

=> allowing users to access specific rows 

 CREATE VIEW V2 
 AS
 SELECT empno,ename,job,deptno 
 FROM emp 
 WHERE deptno = 20 ; 

 GRANT ALL ON V2 TO NARESH ; 

NARESH :-
--------------

 1   SELECT * FROM BATCH53.V2 ; 

  2  INSERT INTO BATCH53.V2 VALUES(101,'K','CLERK',30); 

  above insert command is executed successfully even though it is violating where cond

 WITH CHECK OPTION :- 
 ----------------------------------

 => if view created with  " WITH CHECK OPTION "  then any dml command through view
      violates where cond that dml is not accepted 

 CREATE VIEW V3
 AS
 SELECT empno,ename,job,deptno 
 FROM emp 
 WHERE deptno = 20  
 WITH CHECK OPTION ; 

GRANT ALL ON V3 TO NARESH ;

NARESH :-
-----------------

  INSERT INTO BATCH53.V3 VALUES(102,'K','CLERK',30);   => ERROR

complex views :- 
----------------------

 => a view said to be complex view

 1 if based on multiple tables (joins)
 2 if query contains group by clause
	               distinct clause
                                aggregate functions
                                set operators
                                sub-queries

  => with the help of views complex queries can be converted to simple queries
 
Ex 1 :- 
 
CREATE VIEW CV1
AS
SELECT  e.empno,e.ename,e.sal,
                d.deptno,d.dname,d.loc
FROM emp e INNER JOIN dept d
ON e.deptno = d.deptno ; 

 after creating view whenever user want data from emp & dept tables then instead of 
 writing join query write the simple query 

  SELECT * FROM CV1 ; 
 
Ex 2 :- 

 CREATE VIEW CV2
 AS
 SELECT d.dname, SUM(e.sal) as totsal
 FROM emp e INNER JOIN dept d
 ON e.deptno = d.deptno
 GROUP BY d.dname ;

  after creating view whenever user want dept wise total sal then execute the following simple query

  SELECT * FROM CV2 ; 

 => difference between simple and complex views ?

	simple		`	`	complex

1	based on single table		based on multiple tables

2	query performs simple		query performs complex
	operations			operations like group by ,joins etc

3	always updatable (allows dmls)		not updatable (doesn't allow dmls)

=> list of views created by user ?

  SELECT VIEW_NAME FROM USER_VIEWS ;

 => query associated with V1 ?
 
  SELECT  TEXT FROM USER_VIEWS WHERE VIEW_NAME='V1' ;

 Droping :- 
 ---------------

  DROP VIEW V1 ; 

SYNONYMS :- 
-------------------

 => a synonym is another name or alternative name to table or view

=>  if tablename is lengthy and complex then we can give a simple and short name to
      the table called synonym , after creating synonym instead of using tablename use
      synonym name in SELECT / INSERT / UPDATE / DELETE queries.

         CREATE SYNONYM <NAME> FOR <TABNAME> 

  Granting permission to create synonym :- 
 ---------------------------------------------------------

 SYSTEM :-
 ----------------

    GRANT CREATE SYNONYM TO BATCH53 ;


 BATCH53 :- 
 -------------------

    CREATE SYNONYM E FOR EMP ; 

 after creating synonym instead of using tablename use synonym name

  1 SELECT * FROM E ; 
  2 UPDATE E SET SAL=2000 WHERE EMPNO = 7369;

Question :- 

 1   CREATE SYNONYM E FOR EMP ;
 2   SELECT * FROM EMP E ;
 3   RENAME EMP TO E ;  => changes tablename from EMP to E

 difference between alias  and synonym   ?

	 ALIAS				SYNONYM 

1	not permanent			permanent

2	not stored in db			stored in db

3	scope of the alias is			scope of the synonym is
	upto the query			upto the schema (user).

 => list of synonyms ?
 
  SELECT SYNONYM_NAME,TABLE_NAME FROM USER_SYNONYMS ;

 Droping :-
 ---------------

  DROP SYNONYM  E ; 

 if we drop table what about views created on table ?

 ANS :-  views are not dropped but cannot be queried

 if we drop table table what about synonyms created on table ?

 ans :- synonyms are not dropped but cannot be queried

Question :-

SQL> DROP TABLE products;

What is the implication of this command? (Choose all that apply.)

A. All data along with the table structure is deleted.  T
B. The pending transaction in the session is committed  T.
C. All indexes on the table will remain but they are invalidated.  F
D. All views and synonyms will remain but they are invalidated.  T
E. All data in the table are deleted but the table structure will remain. F

20-NOV-25

SEQUENCES :- 
------------------------

=> a sequence is also a db object created to generate sequence numbers 
=> used to auto increment column values 

 CREATE SEQUENCE <name>
 [START WITH <value>]
 [INCREMENT BY <value>]
 [MAXVALUE <value>]
 [MINVALUE <value>]
 [CYCLE / NOCYCLE]
 [CACHE <size>] ;

Ex 1 :- 
 
 CREATE SEQUENCE S1
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 5 ; 

 CREATE TABLE student
 (
  sid  NUMBER(2),
  sname VARCHAR2(10)
 );

use sequence S1 to generate sid for every new student ?

 INSERT INTO student VALUES(S1.NEXTVAL ,   'A');
 INSERT INTO student VALUES(S1.NEXTVAL ,   'B');
 INSERT INTO student VALUES(S1.NEXTVAL ,   'C');
 INSERT INTO student VALUES(S1.NEXTVAL ,   'D');
 INSERT INTO student VALUES(S1.NEXTVAL ,   'E');
 INSERT INTO student VALUES(S1.NEXTVAL ,   'F');   => ERROR

method 2 :-
-----------------

CREATE TABLE student
 (
  sid  NUMBER(2) DEFAULT S1.NEXTVAL , 
  sname VARCHAR2(10)
 );
 
 INSERT INTO  student(sname) VALUES('A'); 

Ex 2 :- 

 CREATE SEQUENCE S2
 START WITH 100
 INCREMENT BY 1
 MAXVALUE 9999 ;
 
 use sequence s2 to generate values for empno ? 

  UPDATE emp SET empno = s2.nextval ; 

Ex 3 :- 

 BILL
 BILLNO	 	BDATE	  AMT
 DM/201125/1	?	?
 DM/201125/2	?	?

 CREATE TABLE bill
 (
   billno   VARCHAR2(20) ,
   bdate   DATE,
   amt      NUMBER(6)
 );

 CREATE SEQUENCE s3
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 999999;

 use sequence s1 to generate billno ? 

 INSERT INTO bill
     VALUES( 'DM/'||TO_CHAR(sysdate,'DDMMYY')||'/'||S3.NEXTVAL,SYSDATE,2000);

 INSERT INTO bill
     VALUES( 'DM/'||TO_CHAR(sysdate,'DDMMYY')||'/'||S3.NEXTVAL,SYSDATE,3000);

 NOCYCLE :- 
 --------------------

  => if sequence created with NOCYCLE then it starts from start with after reaching max value
       then it stops .

  => if sequence created with CYCLE then after reaching max then it reset to min
  
 => use CYCLE option to reuse sequence.

  CREATE SEQUENCE S5
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5
  MINVALUE 1
  CYCLE
  CACHE 4 ; 

 CACHE size :- 
 ----------------------

 CREATE SEQUENCE S10
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 9999
 MINVALUE 1
 CYCLE
 CACHE 100;

 => oracle preallocates next 100 values in cache memory and eevery time we call 
      seq.nextval then oracle goes to cache memory and return the value from cache memory
      so no of requests going to db are reduced and performance is improved.

 => default cache size is 20 

=> cache size must be less than one cycle.

 Question :-

 CREATE SEQUENCE S10
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 9999
 MINVALUE 1
 CYCLE 
 CACHE 100;
 
  above command fails when executed what could be the reason ? 

  ans :- cache size must be less than 1 cycle.

 => list of sequences created by user ? 

    CREATE SEQUENCE S20 ;

      SELECT MIN_VALUE,MAX_VALUE,INCREMENT_BY,CYCLE_FLAG,CACHE_SIZE
      FROM USER_SEQUENCES
      WHERE SEQUENCE_NAME='S20' ;

 MIN_VALUE  MAX_VALUE INCREMENT_BY C     CACHE_SIZE
 
         1	        1.0000E+28            1                N         20


  Droping :- 
 ------------ 

  DROP SEQUENCE S1 ; 

  How to change sequence parameters :- 
 ------------------------------------------------------- 
 
  ALTER SEQUENCE S20 MAXVALUE 10;
 
 ALTER SEQUENCE S2O CYCLE ;  => ERROR
 
 ALTER SEQUENCE S20 CACHE 9; 

 ALTER SEQUENCE S20 CYCLE ; 

Question :-

CREATE SEQUENCE seq1
START WITH 100
INCREMENT BY 10
MAXVALUE 200
CYCLE
NOCACHE;

The SEQ1 sequence has generated numbers up to the maximum limit of 200. 
 You issue the following SQL stmt :-

SELECT seq1.nextval FROM dual;

What is displayed by the SELECT statement?

A. 1
B. 10
C. 100
D. an error

 ANS :-  A  

 1 Which two statements are true about sequences ? (Choose two.)
	
A. The numbers generated by a sequence can be used only for one table.  F
B. DELETE <sequencename> would remove a sequence from the database.   F
C. CURRVAL is used to refer to the last sequence number that has been generated.  T
D. When the MAXVALUE limit for a sequence is reached, you can increase the MAXVALUE limit
    by using the ALTER SEQUENCE statement. T 
E When a database instance shuts down abnormally, the sequence numbers that have been 
 cached but not used would be available once again when the database instance is restarted. F  

21-nov-25 

 INDEXES :- 
 ------------------

 =>  index is also a db object created to improve the performance of data accessing.

 =>  index makes data accessing faster.

 =>  index in db is similar to index in textbook , in textbook using index a particular topic
       can be located fastly and in db using index a particular row/rows can be located fastly
 
=>   indexes are created on columns and that column is called index key

=>   indexes created on  columns 

   1  which are frequently used in where clause
   2  which are frequently used in join operation

 Types of Indexes :- 
 ---------------------------

 1 BTREE indexes
        simple index
        composite index
        unique index
 2 BITMAP indexes 

 simple btree index :-
 ----------------------------

  =>  if index created on single column then it is called simple index 

          CREATE INDEX <NAME>  ON  <TABNAME> ( COLNAME) ; 

 Ex :-   CREATE INDEX I1 ON EMP(SAL) ; 

EMP				    3000
sal
5000
1000			2000			4000
3000        
1500		1000 *		2500 *             4000 *                5000 * 
4000		1500 *		3000 *,*	
3000		2000 *
2500
2000                                    *    =>  ROWID

    => when we submit query to oracle , it uses following methods to locate the row

 	1  TABLE SCAN
                2   INDEX SCAN

  => In TABLE SCAN , oracle scans complete table i.,e. each and every row.

  => in INDEX SCAN  on avg oracle scans only half of the table  , so index scan is 
       faster than table scan.

        SELECT * FROM emp WHERE sal = 3000 ;   (	INDEX SCAN)
        SELECT * FROM emp WHERE sal >= 3000 ;  (INDEX SCAN)
        SELECT * FROM emp WHERE sal <= 3000 ;  (INDEX SCAN)
  
       SELECT * FROM emp WHERE sal<>3000      (TABLE SCAN)
       SELECT * FROM emp WHERE job='CLERK' ;  (TABLE SCAN)
       SELECT * FROM emp ;

  note :- 

  => execute the following command to see execution plan

      SQL>SET AUTOTRACE ON EXPLAIN 

composite index :- 
----------------------------

  => if index created on multiple columns then it is called compoisite index 

             CREATE INDEX I2 ON EMP(deptno,job) ; 

  =>  In composite index root,intermediate nodes based on deptno and lead nodes 
        contains deptno,job.

			20

	     10                                                       30

  10  CLERK           20  ANALYST *,*     30  CLERK *
  10  MGR               20  CLERK *,*        30   MGR   *
                               20  MGR *              30   SALESMANN *,*,*,*

  => oracle uses above index when where condition based on leading column of the index
       i.e. deptno.

       SELECT * FROM emp WHERE deptno = 20 ;    (INDEX)
       SELECT * FROM emp WHERE deptno=20 AND job='CLERK' ;  (INDEX)
       SELECT * FRONM emp WHERE job='CLERK' ;        (TABLE) 
     
  UNIQUE  index :- 
  -------------------------

  => unique index doesn't allow duplicates  into the column on which index is created 

  EX :-  CREATE  UNIQUE INDEX I3 ON EMP (ENAME) ; 

			      K

	             G				   Q
		
  ALLEN *		       JAMES *	   KING *     	SCOTT *
  ADAMS *                       JONES *               MARTIN *              SMITH *
  BLAKE *                                                     MILLER *               WARD *

  1     SELECT * FROM emp WHERE ename='BLAKE' ; 
 
  2     INSERT INTO emp(empno,ename,sal) VALUES(100,'BLAKE',3000);  => ERROR

 
 what are the different methods to enforce uniqueness ? 

  1  Declare   PRIMARY KEY / UNIQUE constraint
  2  create unique index 

 note :- 

  => primary key / unique columns are implicitly indexed by oracle 

  => oracle creates unique index on primary key  / unique columns 
       and unique index doesn't allow duplicates, so primary key / unique also doesn't allow duplicates 

            primary key  =  unique index + not null 
            unique  =   unique index 

 BITMAP indexes :- 
 ------------------------

 => bitmap indexes created on low cardinality columns i.e. columns that contains less 
      distinct values .

    ex :-   gender,job,state,deptno

  => bitmap index stores bits 

   Ex :-  CREATE  INDEX  BI1 ON EMP(GENDER) 
 
   B1(GENDER)		EMP			BI2(JOB)
   M	F		GENDER	JOB		ANALYST	    CLERK     MGR				
   1	9		M	CLERK		0	    1	    0
   0	1		F	MGR		9	    0               1
   1	0		M	ANALYST                 1                   0               0           
   0           1		F	CLERK                     0                   1               0
   1           0		M	MGR                        0                    0               1
   1           0		M	CLERK                     0                   1               0
 

    SELECT * FROM EMP WHERE GENDER='M' ; 

 difference between btree and bitmap indexes ?

      BTREE			BITMAP 

1   created on high 			created on low cardinality columns
     cardinality columns
      
2    stores index key values		stores bits 


3    stores rowids			doesn't store rowids 

Droping index :- 
----------------------

  DROP INDEX I1 ;
 
 if we drop table what about indexes created on table ? 

 ANS ;-  indexes are also dropped 


 SERVER
      DATABASE
                 USER
                       TABLES
		 ROWS & COLS
 	                 CONSTRAINTS
                                  INDEXES
                                  TRIGGERS
                       VIEWS
                       SYNONYMS
	      SEQUENCES
                       MATERIALIZED VIEWS

                       PROCEDURES
                       FUNCTIONS 
                       PACKAGES

MATERIALIZED VIEWS :-
-----------------------------------

=>  M.VIEW is also a db object that stores query output or precomputed result.

=>  Queries that performs complex joins and group by operations on tables
       that contains huge amount of data takes more time to run ,  so create 
       m.view and stored the query output in m.view and whenever we want
       that output  instead of executing query on table execute query on m.view

 => m.view improves performance of complex joins,group by and aggregate operations

  CREATE MATERIALIZED VIEW <NAME>
  AS
  SELECT statement ;
 
Granting permission to create m.view :- 
-------------------------------------------------

 SYSTEM :-
 ----------------

 GRANT CREATE MATERIALIZED VIEW TO BATCH53 ;

Ex :- 
 
CREATE MATERIALIZED VIEW MV1
AS
SELECT deptno,SUM(sal) as totsal
FROM emp 
GROUP BY deptno ;

=> when above command is executed then oracle execute the query and stores query output 
    in MV1  and whenever we want dept wise total sal then execute the following query

  SELECT * FROM MV1; 

SELECT * FROM MV1;

    DEPTNO     TOTSAL
   ----------        ----------
        30       9400
        10       8750
        20      10875


Refreshing M.view :- 
-------------------------------

 => if base table data changes by default m.view is not updated 
 => updating m.view is called refreshing m.view
 => m.view can be refreshed in 3 ways 

 1 Manually
 2 Automaitcally
          
Manullay :-
---------------

 =>  To refresh m.view execute the following command

    EXECUTE DBMS_MVIEW.REFRESH(M.VIEW NAME);

 
Ex :- 

 STEP 1 : -   update base table 
 
   UPDATE emp SET sal = sal + 1000 ; 

 STEP 2 :-   refresh m.view

   EXECUTE DBMS_MVIEW.REFRESH('MV1');

Automatically :- 
--------------------

 1  REFRESH ON COMMIT
 2  REFRESH BASED ON TIME INTERVAL 

REFRESH ON COMMIT :- 
--------------------------------------

=> once changes made to base table are committed then m.view is refreshed automatically

 CREATE MATERIALIZED VIEW MV2
 REFRESH ON COMMIT
 AS
 SELECT deptno,SUM(sal) as totsal
FROM emp 
GROUP BY deptno ;
 
SELECT * FROM MV2 ;

 DEPTNO     TOTSAL
---------- ----------
        30      15400
        10      11750
        20      15875

STEP  1 :-  update base table 

  UPDATE EMP SET SAL = SAL - 1000;

STEP 2 :-  execute commit

   COMMIT ; 

STEP 3 :-  

 SELECT * FROM MV2 ;

    DEPTNO     TOTSAL
      --------- ----------
        30       9400
        10       8750
        20      10875

REFRESH BASED ON TIME INTERVAL  :- 
------------------------------------------------------------

 => refreshing m.view based on time periods like  hourly,weekly,monthly etc

 CREATE MATERIALIZED VIEW MV3
 REFRESH FORCE
 START WITH SYSDATE NEXT SYSDATE + 7 
 AS
 SELECT deptno,SUM(sal) as totsal
FROM emp 
GROUP BY deptno ;

 => difference between view & m.view ?

         	VIEW				M.VIEW

1       stores query				stores query output 

2       created for sescurity and			created to improve performance
          reduce complexity

3         doesn't store data and doesn't		stores data and occupies memory
           occupy memory		

4          no need to refrehs views		need to refresh m.view

5          if base table is dropped			if base table is dropped
            view cannot be queried			we can query m.view

 
 Droping :- 
----------------
 
DROP MATERIALIZED VIEW MV1;
 
			                    SQL

 commands	clauses		operations		functions		objects
 DDL		WHERE		data filtering		char		tables
 DML		ORDER BY	data sorting		numeric		views
 DRL		DISTINCT		eliminating duplicates	date		synonyms
 TCL		FETCH		top n rows			conversion	sequences
 DCL		GROUP BY	data grouping		analytical		indexes					
		HAVING		filters groups		group 		m.views
		ON		joining
				set operations
                                                                   lookup
				data pivoting
		

============================================================================

24-NOV-25 

			 PL/SQL (Procedural Lang)
                                                   -----------------------------------
 
1  basic programming
2  conditional statements 
3  loops
4  cursors
5  error handling
6  procedures
7  functions
8  packages
9  triggers
10  dynamic sql 
11  storing multimedia objects in db 

 Features :- 
--------------

 1   improves performance :- 
     --------------------------------
 
    => In PL/SQL  ,  sql commands can be  grouped into one block and we submit that block to oracle 
         and oracle executes that block and sends response, so in pl/sql no of requests and response
        between user and oracle are reduced and performance is improved.

  2  supports conditional statements :- 
     ------------------------------------------------

   => pl/sql supports conditional statements like IF-THEN-ELSE ,  so in pl/sql 
       we can execute sql commands based on conditions.

 3   supports loops :- 
  ---------------------------

  => pl/sql supports loops like while,for etc , so with the loops we can execute
       sql commands repeatedly multiple times.

 4  supports error handling :- 
    ----------------------------------

   => pl/sql supports error handling , so in pl/sql if any statement causes error then
        we can handle that error and we can replace system generated message with
        our own simple and user friendly message.

  5   supports reusability :- 
       ----------------------------

  => pl/sql programs can be stored in db , so applications  like java,python which are connected 
       to oracle can invoke pl/sql programs

 => PL/SQL blocks are 2 types 

1 anonymous blocks
2 named blocks 
           procedures
           functions
           packages
           triggers

Anonymous Blocks :- 
------------------------------

  => a program without name is called anonymous block

    DECLARE
        <declaration-part>;               (optional)
    BEGIN
        <execution-part>;
    END;
     / 

How to print messages :- 
----------------------------------

  DBMS_OUTPUT.PUT_LINE(message) ;
  ---------------------- ----------------------------
        PACKAGE       PROCEDURE

=> by default messages are not send to output , to send messages to output execute the
      following command

  SQL>SET SERVEROUTPUT ON 

 Datatypes in pl/sql :- 
---------------------------------

 1  scalar types 
 2  user defined types 
 3  reference types 

scalar types :- 
--------------------

 => all built-in types are called scalar types 

  1 Number(p) / Number(p,s)
  2 char/varchar2/long/clob
  3 nchar/nvarchar2/nclob
  4 bfile / blob
  5 date/timestamp
  6 binary_float /binary_double
  7 binary_integer
  8 boolean
  

   1 to 6   => allowed in sql,pl/sql
   7,8       => allowed only in pl/sql 

 Declaring variable :- 
----------------------------

    variablename   datatype(size);

 Ex :- 
   
          x    NUMBER(4);
          s    VARCHAR2(10);
          d    DATE;
          b    BOOLEAN;

Assigning value to variable :-
-----------------------------------------

            variablename  :=   value ; 

        :=    =>   assignment operator 

 Ex :- 

             x   = 1000;   => wrong

             x := 1000;
             s := 'abc';
             d := SYSDATE;
             b  :=  TRUE;

 How to write pl/sql programs :- 
 -------------------------------------------

 1 using EDITORs 
 2 using IDEs 

              		 EDITOR		IDE

    coding		yes		yes

    compilation	no		yes

    execution	no		yes

    debugging	no		yes

   ex		notepad		sql developer / toad


using notepad :- 
---------------------- 

=> open notepad and enter following code 

   DECLARE
      a NUMBER(3);
      b NUMBER(3);
      c NUMBER(3);
    BEGIN
        a := 100;
        b := 200;
        c := a+b;
        DBMS_OUTPUT.PUT_LINE(c);
    END;
    /
 
 => save the program in a file   D:\ "PROG1.SQL" 
=> go to sqlplus and compile and run the program as follows 
 
   SQL>@D:\PROG1.SQL   

  output :- 300

How to input values at runtime :- 
----------------------------------------------

  SET VERIFY OFF

  DECLARE
      a NUMBER(3);
      b NUMBER(3);
      c NUMBER(3);
    BEGIN
        a :=  &a;
        b := &b;
        c := a+b;
        DBMS_OUTPUT.PUT_LINE(c);
    END;
    /

Enter value for a: 80
Enter value for b: 40

  OUTPUT :-  120

=> wap to input date and print day of the week ? 

    DECLARE
         d       DATE;
    BEGIN
         d :=   '&DATE';
         DBMS_OUTPUT.PUT_LINE(TO_CHAR(d,'day'));
   END;
     /

=> wap to input name and print first name,middle name,last name ?

     DECLARE
             n   VARCHAR2(30);
             f    VARCHAR2(20);
             m  VARCHAR2(20);
             l    VARCHAR2(20);
      BEGIN
           n  :=  '&name' ;     /* sachin ramesh tendulkar */ 
           f  :=  SUBSTR(n,1,INSTR(n,' ')-1);      
           l  :=  SUBSTR(n,INSTR(n,' ',1,2)+1);
           m  :=    RTRIM( LTRIM(n,f) , l);
           DBMS_OUTPUT.PUT_LINE('First Name = '||f);
           DBMS_OUTPUT.PUT_LINE('Middle Name = '||m);
           DBMS_OUTPUT.PUT_LINE('Last Name = '||l);
       END;
              /

 SUBSTR(string,start,no of chars)

 INSTR(string,char,[start, occurance])

          RTRIM( LTRIM(n,f) , l)

output :- 

Enter value for name: sachin ramesh tendulkar

First Name = sachin
Middle Name =  ramesh
Last Name = tendulkar
 
using REGEXPR_SUBSTR() :- 
-------------------------------------------

 REGEXP_SUBSTR(string,pattern,start,occurance);

    DECLARE
             n   VARCHAR2(30);
             f    VARCHAR2(20);
             m  VARCHAR2(20);
             l    VARCHAR2(20);
      BEGIN
           n  :=  '&name' ;     /* sachin ramesh tendulkar */ 
           f  :=    REGEXP_SUBSTR(n,'[a-z]+',1,1);   
           m  :=  REGEXP_SUBSTR(n,'[a-z]+',1,2);   
           l  :=    REGEXP_SUBSTR(n,'[a-z]+',1,3);   
           DBMS_OUTPUT.PUT_LINE('First Name = '||f);
           DBMS_OUTPUT.PUT_LINE('Middle Name = '||m);
           DBMS_OUTPUT.PUT_LINE('Last Name = '||l);
       END;
              /
 
25-nov-25

 DB programming with PL/SQL :- 
 ---------------------------------------------- 

 => from pl/sql to work with db execute sql commands from pl/sql program
 => the following commands can be executed from pl/sql 
 
1 DML (insert,update,delete,merge)
2 DRL  (select)
3 TCL  (commit,rollback,savepoint)

 SELECT stmt syntax :- 
 ----------------------------

 SELECT columns INTO variables
 FROM tabname
 WHERE condition ; 

 Ex :- 

  SELECT ename,sal INTO  n,s 
  FROM emp 
  WHERE empno = 7844;

=> wap to input empno and print name & salary ? 

   DECLARE
       v_empno    NUMBER(4);
       v_name      VARCHAR2(10);
       v_sal           NUMBER(7,2);
   BEGIN
        v_empno := &empno;
        SELECT ename,sal INTO  v_name,v_sal
        FROM emp 
        WHERE empno =  v_empno ;
        DBMS_OUTPUT.PUT_LINE(v_name||'  '||v_sal);
   END;
     /

Enter value for empno: 7566
JONES  2975

=> wap to input empno and calculate and print experience in years ?

    DECLARE
        v_eno   NUMBER(4);
        v_hire   DATE;
        v_expr  NUMBER(2);
   BEGIN
        v_eno := &empno;     /* 7369 */
        SELECT hiredate INTO v_hire FROM emp WHERE empno = v_eno;
        v_expr :=  (SYSDATE-v_hire)/365;
        DBMS_OUTPUT.PUT_LINE('Experience =  '||v_expr|| ' years');
   END;
    /

Enter value for empno: 7369
Experience =  45 years
 
=> wap to input empno and calculate and print total sal  ? 
      
               total sal = sal + comm

  DECLARE
       v_eno  NUMBER(4);
       v_sal   NUMBER(7,2);
       v_comm NUMBER(7,2);
       v_totsal  NUMBER(8,2);
  BEGIN
       v_eno := &empno;
       SELECT sal,comm INTO v_sal,v_comm FROM emp WHERE empno = v_eno;
       v_totsal := v_sal + NVL(v_comm,0);
       DBMS_OUTPUT.PUT_LINE('Total sal = '||v_totsal);
  END;
     /

Enter value for empno: 7369
Total sal = 800

Conditional statements :- 
--------------------------------

 1  IF-ELSE
 2  multi IF
 3  nested IF

IF-ELSE :- 
-------------

 IF cond THEN
    statements;
 ELSE
    statements;
 END IF;

 multi IF :- 
-------------

  IF cond1 THEN
       statements;
  ELSIF cond2 THEN
      statements; 
 ELSIF cond3 THEN
      statements;
 ELSE
      statements;
 END IF;

nested IF :- 
---------------

  IF cond THEN
      IF cond THEN
          statements;
       ELSE
          statements;
       END IF;
  ELSE
       statements;
  END IF;

Ex :- 

 => wap to input empno and increment sal by specific amount
      and after increment if sal exceeds 5000 then cancel that increment ?

     DECLARE
         v_eno   NUMBER(4);
         v_amt   NUMBER(4);
         v_sal    NUMBER(7,2);
    BEGIN
         v_eno := &empno;    /*  7788 */
         v_amt := &amount;   /*  2500 */
         UPDATE emp SET sal = sal + v_amt  WHERE empno = v_eno ; 
         SELECT sal INTO v_sal FROM emp WHERE empno = v_eno;
         IF v_sal > 5000 THEN
              ROLLBACK;
         ELSE
              COMMIT;
         END IF;
   END;
      /

=> wap to input empno and increment sal as follows ?

      IF  job=CLERK  incr sal by 10%
                  SALESMAN            15%
                  MANAGER              20%
                   others                     5%
                   
    DECLARE
         v_eno  NUMBER(4);
         v_job   VARCHAR2(10);
         v_pct   NUMBER(2); 
         v_sal   NUMBER(7,2);
    BEGIN
         v_eno := &empno;
         SELECT job INTO v_job FROM emp WHERE empno = v_eno;
         IF v_job='CLERK'  THEN
            v_pct := 10;
         ELSIF v_job='SALESMAN'  THEN
            v_pct := 15;
         ELSIF v_job='MANAGER'  THEN
            v_pct := 20;
        ELSE
            v_pct := 5;
        END IF;
        UPDATE emp SET sal = sal + (sal*v_pct/100) WHERE empno = v_eno;
        COMMIT;
        SELECT sal INTO v_sal FROM emp WHERE empno = v_eno;
        DBMS_OUTPUT.PUT_LINE('updated salary = '||v_sal);
  END;
    /

Enter value for empno: 7902
updated salary = 3150

================================================================

26-nov-25

=> wap to process bank transaction (w/d)  ? 

ACCOUNT
 accno	actype	bal
100	S	10000
101	S	20000

TRANSACTIONS
 trid	ttype	tdate	tamt	accno

 CREATE TABLE ACCOUNTS
    (
     ACCNO  NUMBER(4) PRIMARY KEY,
     ACTYPE  CHAR(1) ,
     BAL  NUMBER(7)
     );

SQL> INSERT INTO ACCOUNTS VALUES(100,'A',10000);

SQ> INSERT INTO ACCOUNTS VALUES(102,'B',20000);

CREATE TABLE TRANSACTIONS
(
  TRID  NUMBER   PRIMARY KEY , 
  TTYPE  CHAR(1),
  TDATE  DATE ,
  TAMT    NUMBER(6),
  ACCNO   NUMBER(5) REFERENCES  ACCOUNTS(ACCNO)
 );

CREATE SEQUENCE S10
START WITH 1
INCREMENT BY 1
MAXVALUE 9999;

DECLARE
   v_acno    NUMBER(4);
   v_type     CHAR(1);
   v_amt      NUMBER(5);  
   v_bal       NUMBER(7);
BEGIN
    v_acno := &acno;
    v_type := '&type';              
    v_amt  := &amount;
    IF v_type='W'  THEN
       SELECT bal INTO v_bal FROM accounts WHERE accno = v_acno;
       IF v_amt > v_bal THEN
          DBMS_OUTPUT.PUT_LINE('insufficient balance');
      ELSE
          UPDATE accounts SET bal = bal - v_amt WHERE accno = v_acno ;
          INSERT INTO transactions VALUES(s10.nextval ,'w',sysdate,v_amt,v_acno);
          COMMIT;
      END IF;
   ELSIF v_type='D' THEN
         UPDATE accounts SET bal = bal + v_amt WHERE accno = v_acno;
         INSERT INTO transactions VALUES(s10.nextval ,'d',sysdate,v_amt,v_acno);
         COMMIT;
   ELSE
        DBMS_OUTPUT.PUT_LINE('invalid trnsaction type');
   END IF;
 END;
  /

=> wap to process money transfer ? 

 DECLARE
   v_sacno      NUMBER(4);
   v_tacno      NUMBER(4);
   v_amt         NUMBER(5);
   v_bal          NUMBER(7);
 BEGIN
     v_sacno := &sacno;      /* 100 */
     v_tacno  := &tacno;      /* 101 */
     v_amt   := &amount;    /*  1000 */ 
     SELECT bal INTO v_bal FROM accounts WHERE accno = v_sacno ;
     IF v_amt > v_bal THEN
         DBMS_OUTPUT.PUT_LINE('insufficient balance');
    ELSE
         UPDATE accounts SET bal = bal - v_amt WHERE accno = v_sacno ; 
         UPDATE accounts SET bal = bal + v_amt WHERE accno = v_tacno ; 
         INSERT INTO transactions VALUES(s10.nextval,'w',sysdate,v_amt,v_sacno);
         INSERT INTO transactions VALUES(s10.nextval,'d',sysdate,v_amt,v_tacno);
        COMMIT;
   END IF;
END;
  /

Reference Types :- 
---------------------------

 => pl/sql supports 2 reference types 

 1 %TYPE
 2  %ROWTYPE 

 %TYPE :- 
 -----------

 => used to refer column datatype.
 
 Ex 1  :-   v_bal    accounts.bal%TYPE;

 => whatever datatype and size declared for  accounts table bal field  the same type and
      size assigned to variable  v_bal .

 => Adv of %TYPE is even if column type or size changes pl/sql program is not affected , so
     this reduces complexity.

Ex 2 :-    v_ename  emp.ename%TYPE;
              v_sal        emp.sal%TYPE;

 %ROWTYPE :- 
 ----------------------

 => %ROWTYPE is used to refer row type.

    ex :-    r     emp%ROWTYPE;

 =>  a row from emp table can be assigned to variable "r".

     SELECT *  INTO  r   
     FROM emp 
    WHERE empno = 7844; 

    r
    empno	 ename   job  	 mgr 	hiredate	sal	comm	deptno
    7844	 turner   salesman		?	1500	0	30

   => from the rowtype variable individual field values are accessed by using rowtypevar.fieldname

   ex :-   r.sal   => 1500
             r.ename  => turner
             r.deptno => 30

 Ex :- 

 STUDENT
 sno	sname	s1	s2	s3
 1	A	80	90	70
 2	B	30	50	40

RESULT
sno	total	avg	result

=> wap to input sno and calculate total,avg,result and insert into result table ? 

 DECLARE
    v_sno  student.sno%TYPE;
    s         student%ROWTYPE;
    r          result%ROWTYPE;
BEGIN
    v_sno := &sno ;   
    SELECT *  INTO s  FROM student WHERE sno = v_sno ; 
    r.total := s.s1 + s.s2 + s.s3; 
    r.avg :=  r.total/3;
    IF s.s1>=35 AND s.s2>=35 AND s.s3>=35 THEN
        r.result := 'pass' ;
    ELSE
        r.result := 'fail';
    END IF;
    INSERT INTO result VALUES(v_sno,r.total,r.avg,r.result);
    COMMIT;
 END;
 /
 

 s
 sno	sname	s1	s2	s3
 1	A	80	90	70

r
sno	total	avg	result
                240           80            PASS

LOOPS :- 
-------------

 1 simple loop
 2 while loop
 3 for loop 

simple loop :- 
------------------

 LOOP
    statements;
    EXIT WHEN cond;
END LOOP;

  if cond = false loop continues
  if cond = true loop terminates

WHILE loop :-
------------------

 WHILE(cond)
 LOOP
    statements; 
END LOOP;

 if cond = true loop continues
 if cond = false loop terminates

 FOR loop :- 
-----------------

 FOR <var> IN <low>..<upp>
 LOOP
   statements; 
 END LOOP;

Ex :- 

 FOR  x  IN 1..10
 LOOP
   statements;
 END LOOP;

=> loop variable "x"  is declared implicitly as number type
=> "x" implicitly incremented by 1
=> "x" is readonly variable
=>  scope of "x" is upto the for loop
 
 Ex :-  

 => wap to print nos from 1 to 20 ? 

using simple loop :- 
--------------------------
 
DECLARE
  x  NUMBER(2)  :=  1 ;
BEGIN
  LOOP
      DBMS_OUTPUT.PUT_LINE(x);
      x := x+1;
      EXIT WHEN x>20;
 END LOOP;
END;
  /

using while loop :-
-------------------------

DECLARE
  x  NUMBER(2)  :=  1 ;
BEGIN
  WHILE(x<=20)
  LOOP
      DBMS_OUTPUT.PUT_LINE(x);
       x := x+1;
 END LOOP;
END;
 /

using for loop :-
------------------------

BEGIN
   FOR x  IN  1..20
   LOOP
     DBMS_OUTPUT.PUT_LINE(x);
  END LOOP;
END;

BEGIN
   FOR x  IN 1..20
   LOOP
     DBMS_OUTPUT.PUT_LINE(x);
  END LOOP;
   DBMS_OUTPUT.PUT_LINE(x);        => ERROR  => scope of the 'x' is upto the for loop
END;
 /


BEGIN
   FOR x  IN 2..20
   LOOP
     DBMS_OUTPUT.PUT_LINE(x);
     x := x+2;                                        => ERROR  => 'x' is readonly variable
  END LOOP;
END;
 /

Reverse for loop :-
----------------------------

BEGIN
   FOR x  IN REVERSE  1..20
   LOOP
     DBMS_OUTPUT.PUT_LINE(x);
  END LOOP;
END;
 /

=>  x initialized with 20
=> everytime value of x decrement by 1 

=> wap to print 2026 calendar ? 

    01-jan-26	??
    02-jan-26	??

    31-dec-26	??

   DECLARE
      d1  DATE;
      d2 DATE;
  BEGIN
       d1 := '01-JAN-26' ;
       d2 := '31-DEC-26';
       WHILE(d1 <= d2) 
      LOOP
            DBMS_OUTPUT.PUT_LINE(d1||'     '||TO_CHAR(d1,'day'));
            d1 := d1+1;
      END LOOP;
   END;
       /

=> wap to print sundays between two given dates ? 

     DECLARE
      d1  DATE;
      d2 DATE;
  BEGIN
       d1 := '01-JAN-25' ;
       d2 := '31-DEC-25';
       WHILE(d1 <= d2) 
      LOOP
            IF TO_CHAR(d1,'dy') = 'sun' THEN
                  DBMS_OUTPUT.PUT_LINE(d1||'     '||TO_CHAR(d1,'day'));
            END IF;
            d1 := d1+1;
      END LOOP;
   END;
       /

 DECLARE
      d1  DATE;
      d2 DATE;
  BEGIN
       d1 := '01-JAN-25' ;
       d2 := '31-DEC-25';
       d1 := NEXT_DAY(d1,'sunday');
      WHILE(d1 <= d2) 
      LOOP
            DBMS_OUTPUT.PUT_LINE(d1||'     '||TO_CHAR(d1,'day'));
            d1 := d1+7;
      END LOOP;
   END;
       /

 => wap to insert emi dates into loans table

      tenure :-  20 years
      emi dt  :-  5-dec-25

    loans
    rno	emi_dt	amount	
 
  CREATE TABLE loans
  (
  rno  NUMBER , 
  emi_dt   DATE,
  amount NUMBER
 );

 DECLARE
  d1  DATE;
  d2  DATE; 
  x  NUMBER  := 1;
 BEGIN
    d1 := LAST_DAY(SYSDATE)+5 ;
    d2 := ADD_MONTHS(d1,20*12);
    WHILE(d1<=d2)
    LOOP
         INSERT INTO loans VALUES(x,d1,NULL);
         d1 := ADD_MONTHS(d1,1);
         x := x+1;
    END LOOP;
 END;
   /

=> wap to input string and print the following pattern ?

          input :-  NARESH

         output :- 

  N
  A
  R
  E
  S
  H

 DECLARE
       s1  VARCHAR2(20);
  BEGIN
       s1 := '&string' ;
       FOR x IN 1..LENGTH(s1)
       LOOP
             DBMS_OUTPUT.PUT_LINE(SUBSTR(s1,x,1));
      END LOOP;
 END;
  /

 
 SUBSTR(string,start,no of chars)


=> wap to input string and print the following pattern ?

          input :-  NARESH

         output :- 

  N
  NA
  NAR
  NARE
  NARES
  NARESH

  DECLARE
       s1  VARCHAR2(20);
  BEGIN
       s1 := '&string' ;
       FOR x IN 1..LENGTH(s1)
       LOOP
             DBMS_OUTPUT.PUT_LINE(SUBSTR(s1,1,x));
      END LOOP;
 END;
  /

=> wap to input string and print reverse ? 

   DECLARE
       s1  VARCHAR2(20); 
       s2  VARCHAR2(20);
  BEGIN
       s1 := '&string' ;
       FOR x IN 1..LENGTH(s1)
       LOOP
            S2 :=  S2||SUBSTR(s1,-x,1);
      END LOOP;
      DBMS_OUTPUT.PUT_LINE(s2);
      IF s1=s2 THEN
          DBMS_OUTPUT.PUT_LINE('palindrome');
      ELSE
           DBMS_OUTPUT.PUT_LINE(' not a palindrome');
     END IF;
  END;
   /
  
CURSORS :-    (Explicit Cursor)
==========================

 => cursors are used to process multiple rows in pl/sql program.

 => using cursor we can access row-by-row in pl/sql program.

 => from pl/sql program if we submit a query to oracle , it goes to db and 
      copies the query output to cursor created in instance and in pl/sql prog
      we can give name to the cursor and access row-by-row from cursor and process the row.

 => follow below steps to use cursor 

 1 DECLARE  
 2 OPEN  
 3 FETCH
 4 CLOSE

 DECLARE :- 
 -----------------

         CURSOR <name> IS SELECT statement ;

Ex :-  CURSOR C1 SELECT ename,sal FROM emp ; 

OPEN :-
---------

                  OPEN <cursor-name>;
 
Ex :-         OPEN C1;

 =>   select stmt declared with cursor is submitted to oracle
 =>   oracle executes the query and data returned by query is copied to cursor
 =>   c1 points to cursor

FETCH :-
--------------

  => "FETCH" stmt is used to fetch record from cursor

                 FETCH <cursor-name> INTO <variables> ;

 Ex :-       FETCH C1 INTO  v_ename,v_sal;

 => a fetch stmt fetches one row at a time but to process multiple rows fetch stmt should
      be executed multiple times , so fetch stmt should be in a loop.

CLOSE :-
-------------

             CLOSE  <cursor-name> ; 

 ex :-      CLOSE C1; 

  28-NOV-25 

  cursor attributes :- 
  ------------------------
   
  %found :- 
  -------------

  TRUE	 =>   if fetch successful
   FALSE   =>    if fetch unsuccessful

  %notfound :- 
   ----------------

    TRUE 	 =>   if fetch unsuccessful
    FALSE	 =>   if fetch successful

   %rowcount :- 
   ------------------

   => returns no of rows fetched successfully

 C1%FOUND
 C1%NOTFOUND
 C1%ROWCOUNT 

Ex :- 

 => wap to print all employee names and salaries ?

using simple loop :-
-----------------------------

  DECLARE
     CURSOR C1  IS SELECT  ename,sal FROM emp ;
     vename   emp.ename%TYPE;
     vsal         emp.sal%TYPE;
 BEGIN
        OPEN C1;
   LOOP
        FETCH C1 INTO vename,vsal;
        EXIT WHEN  C1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(RPAD(vename,6,' ')||'   '||vsal);
   END LOOP;
       CLOSE C1;
 END;
   /

 using while loop :-
---------------------------

 DECLARE
     CURSOR C1  IS SELECT  ename,sal FROM emp ;
     vename   emp.ename%TYPE;
     vsal         emp.sal%TYPE;
 BEGIN
        OPEN C1;
        FETCH C1 INTO vename,vsal;
        WHILE(C1%FOUND)
   LOOP
        DBMS_OUTPUT.PUT_LINE(RPAD(vename,6,' ')||'   '||vsal);
        FETCH C1 INTO vename,vsal;
   END LOOP;
       CLOSE C1;
 END;
   /

using for loop cursor /  cursor for loop :-
-------------------------------------------------------

 FOR <var> IN  <cursor-name>
 LOOP
        statements;
 END LOOP;

 Ex :- 

  FOR  r  IN C1
  LOOP
     statements;
 END LOOP;

 => Adv of for loop cursor is opening ,fetching  and closing in not required 
      and all these operations performed implicitly.

=> for loop is executed no of times depends on no of rows in cursor

=> everytime for loop executes a row fetched from cursor and copied to loop variable "r".

=> loop variable "r" is also declared implicitly as rowtype.


   DECLARE
       CURSOR C1 IS SELECT ename,sal FROM emp ;
   BEGIN
       FOR r IN C1
       LOOP
            DBMS_OUTPUT.PUT_LINE(r.ename||'   '||r.sal);
      END LOOP;
 END;
  / 
 
inline cursor :-
---------------------

 BEGIN
       FOR r IN (SELECT ename,sal FROM emp) 
       LOOP
            DBMS_OUTPUT.PUT_LINE(r.ename||'   '||r.sal);
      END LOOP;
 END;
  / 
 
=> wap to calculate total sal paid to all employees without using sum function ? 

  DECLARE
       CURSOR C1 IS SELECT sal FROM emp ;
       t NUMBER := 0;
  BEGIN
      FOR r IN C1
    LOOP
       t := t + r.sal;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('Total sal = '||t);
  END;
    / 

=> wap to find max sal without using max function ? 

   DECLARE
       CURSOR C1 IS SELECT sal FROM emp ;
       m NUMBER := 0;
       vsal NUMBER ; 
  BEGIN
      OPEN C1;
      FETCH C1 INTO m;
      WHILE(C1%FOUND)
      LOOP
          FETCH C1 INTO vsal;
          IF vsal > m THEN
               m := vsal;
         END IF;
      END LOOP;
      CLOSE C1;
      DBMS_OUTPUT.PUT_LINE('Max salary = '||m);
  END;
    /

DECLARE
   CURSOR C1 IS SELECT sal FROM emp ORDER BY sal DESC ;
   vsal  NUMBER;
BEGIN
   OPEN C1;
   FETCH C1 INTO vsal;
   DBMS_OUTPUT.PUT_LINE(vsal);
   CLOSE C1;
END;
  /

=> wap to print min sal ? 

   DECLARE
       CURSOR C1 IS SELECT sal FROM emp ;
       m NUMBER := 0;
       vsal NUMBER ; 
  BEGIN
      OPEN C1;
      FETCH C1 INTO m;
      WHILE(C1%FOUND)
      LOOP
          FETCH C1 INTO vsal;
          IF vsal < m THEN
               m := vsal;
         END IF;
      END LOOP;
      CLOSE C1;
      DBMS_OUTPUT.PUT_LINE('Max salary = '||m);
  END;
    /

DECLARE
   CURSOR C1 IS SELECT sal FROM emp ORDER BY sal ASC ;
   vsal  NUMBER;
BEGIN
   OPEN C1;
   FETCH C1 INTO vsal;
   DBMS_OUTPUT.PUT_LINE(vsal);
   CLOSE C1;
END;
  /
 
=> wap to print following output ?  (master / detail report) 

  10	ACCOUNTS
      -----	------	-----
      -----    -------         -----
       ----- 

 20       RESEARCH
 
      ------   --------      -----------
      -------  --------      ----------

 30    SALES

     ---------    ------        ----


 BEGIN
    FOR d  IN   (SELECT deptno,dname FROM dept)
   LOOP
       DBMS_OUTPUT.PUT_LINE(d.deptno||'  '||d.dname);
        FOR e IN (SELECT empno,ename,sal FROM emp WHERE deptno = d.deptno)
      LOOP
           DBMS_OUTPUT.PUT_LINE(e.empno||'  '||e.ename||'  '||e.sal);
     END LOOP;
 END LOOP;
END;
 /

=> 

 STUDENT
 sno	sname	s1	s2	s3
 1	A	80	90	70
 2	B	30	50	40

RESULT
sno	total	avg	result

=> wap to  calculate all students total,avg,result and insert into result table ? 

 DECLARE
   CURSOR C1 IS SELECT sno,s1,s2,s3 FROM student;
    r  result%ROWTYPE;
BEGIN
     FOR s IN C1
 LOOP
    r.total := s.s1 + s.s2 + s.s3; 
    r.avg :=  r.total/3;
    IF s.s1>=35 AND s.s2>=35 AND s.s3>=35 THEN
        r.result := 'pass' ;
    ELSE
        r.result := 'fail';
    END IF;
    INSERT INTO result VALUES(s.sno,r.total,r.avg,r.result);
END LOOP;
    COMMIT;
END;
 /

29-nov-25 
 
=> wap to increment employee salaries based on pct in sal_hike table ?

 SAL_HIKE
 empno	pct 
 7369	10
 7499	15
 7521	20
 7654	15

 DECLARE
     CURSOR C1 IS SELECT empno,pct FROM sal_hike ;
 BEGIN
     FOR r IN C1
     LOOP
            UPDATE emp SET sal = sal + (sal * r.pct/100) WHERE empno = r.empno;
    END LOOP;
    COMMIT;
 END;
  /

 FOR UPDATE clause :-
--------------------------------

 => if cursor declared with FOR UPDATE clause then records return by select stmt are
      locked , an exclusive lock is applied on records return by select stmt and the
      records are not available to other transactions until the lock releases.


  Ex :-

       CURSOR C1 IS SELECT *  FROM emp FOR UPDATE OF SAL  NOWAIT ; 

  => records returned by select stmt are locked (exclusive) .

 =>  NOWAIT specifies  , if records are already locked by some other transaction
       then oracle will not put the request in wait state  instead oracle throws error.
    
  DECLARE
     CURSOR C1 IS SELECT empno,sal FROM emp FOR UPDATE NOWAIT;
 BEGIN
   FOR r IN C1
  LOOP
    UPDATE emp SET sal = sal + 1000 WHERE empno = r.empno;
 END LOOP;
 END;
  /

WHERE current of clause :-
--------------------------------------

 => used to access current record of the cursor
 => used to update data in a table which doesn't contain primary key
=>  to use current of clause cursor must be declared FOR UPDATE clause

  T1
  ENAME	SAL
  A	5000 + 1000 + 1000
  B	6000 + 1000 + 1000
  C	7000 + 1000
  A	8000 + 1000 + 1000
  B	4000 + 1000 + 1000
 
DECLARE
   CURSOR C1 IS SELECT * FROM T1 ; 
BEGIN
   FOR r  IN C1
  LOOP
     UPDATE T1 SET SAL = SAL + 1000 WHERE ENAME = r.ENAME ; 
END LOOP;
END;
 /
 
 => in the above example program is for incrementing sal by 1000 but 
       employee 'A','B' salaries incremented by 2000 because of duplicates  ,
      To overcome this problem use CURRENT OF clause.
 
DECLARE
   CURSOR C1 IS SELECT * FROM T1  FOR UPDATE OF SAL NOWAIT ; 
BEGIN
   FOR r  IN C1
  LOOP
     UPDATE T1 SET SAL = SAL + 1000 WHERE CURRENT OF C1 ;
END LOOP;
END;
 /

=>  wap to update f3 as follows ? 

 T1
 F1	F2	F3
 5	4	F1+F2
 5	4	F1-F2
 5	4	F1*F2	
 5	4	F1/F2
 5	4	F1+F2
 5	4	F1-F2
 5	4	F1*F2	
 5	4	F1/F2
 5	4	F1+F2
 5	4	F1-F2
 5	4	F1*F2	
 5	4	F1/F2
 5	4	F1+F2
 5	4	F1-F2
 5	4	F1*F2	
 5	4	F1/F2
 5	4	F1+F2
 5	4	F1-F2
 5	4	F1*F2	
 5	4	F1/F2

 DECLARE
    CURSOR C1 IS SELECT * FROM T1 FOR UPDATE OF F3 NOWAIT ;
BEGIN
    FOR r  IN C1
    LOOP
         IF  MOD(C1%ROWCOUNT,4) = 1 THEN
               UPDATE T1 SET F3 = F1 + F2 WHERE CURRENT OF C1;
         ELSIF MOD(C1%ROWCOUNT,4)=2 THEN
                UPDATE T1 SET F3 = F1-F2 WHERE CURRENT OF C1 ;
         ELSIF MOD(C1%ROWCOUNT,4) = 3 THEN
                 UPDATE T1 SET F3 = F1*F2 WHERE CURRENT OF C1 ;
          ELSE
                  UPDATE T1 SET F3 = F1/F2 WHERE CURRENT OF C1 ;
           END IF;
  END LOOP;
  COMMIT;
 END;
   /


  MOD(1,4) => 1
  MOD(2,4) => 2
  MOD(3,4) => 3
  MOD(4,4) => 0 

  MOD(5,4) => 1
  MOD(6,4) = > 2
  MOD(7,4) = > 3
  MOD(8,4) => 0
  
  Dynamic CURSOR  / REF CURSOR :- 
  ---------------------------------------------------

 => a cursor acts like a constant because select stmt declared with cursor cannot be
      changed during program execution but refcursor acts liike a variable because
      select stmt can be changed during program execution.

 => a cursor is called static but refcursor is called dynamic.

 How to declare REF CURSOR :-
 ----------------------------------------------
 
       C1    SYS_REFCURSOR;
 
How to assign data to cursor :-
-------------------------------------------

     OPEN C1 FOR SELECT * FROM emp ;

    CLOSE C1;

    OPEN C1 FOR SELECT * FROM dept;

    CLOSE C1;

  
Ex :-  
 
DECLARE
    C1  SYS_REFCURSOR;
    e     emp%ROWTYPE;
    d     dept%ROWTYPE;
BEGIN
   OPEN C1 FOR SELECT * FROM emp ;
   LOOP
     FETCH C1 INTO e;
     EXIT WHEN C1%NOTFOUND;
     DBMS_OUTPUT.PUT_LINE(e.ename||'  '||e.sal);
  END LOOP;
    CLOSE C1;
    OPEN C1 FOR SELECT * FROM dept;
  LOOP
      FETCH C1 INTO d;
      EXIT WHEN C1%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(d.dname|| ' '||d.loc);
  END LOOP;
      CLOSE C1;
 END;
    /
   
 difference between cursor and refcursor ?

	  cursor				refcursor

1    acts like a constant			acts like a variable

2    select stmt cannot be			select stmt can be
      changed during program			changed during program
      execution				execution

3    static					dynamic

4    select stmt assigned to cursor		select stmt assigned to cursor
      at the time of declaration			at the time of opening 

5    cannot be used as proc,func		can be used as proc,fun parameter
      parameter

different types of cursor ?

 1  explicit cursor
             cursor
             ref cursor
 2  implicit cursor

1-dec-25 

 Implicit cursor :- 
 ------------------------

 => cursor declared by oracle is called implicit cursor.
 => oracle declare cursor immediately after execution of dml command.
 => implicit cursors are used to process output of dml commands.
 => implicit cursors are used to find whether last dml is successful or not.
 => name of the implicit cursor is SQL 
 

SQL%FOUND =>  TRUE    => if last dml is successful
	              FALSE   => if last dml is unsuccessful

SQL%NOTFOUND => TRUE      =>  if last dml is unsuccessful
                                     FALSE     => if last dml is successful

 SQL%ROWCOUNT  => returns no of rows affected by last dml

Ex 1 :- 

 => wap to input empno and delete the row ? 

     DECLARE
          v_eno   emp.empno%TYPE;
     BEGIN
          v_eno  := &empno;  
           DELETE FROM emp WHERE empno = v_eno ; 
           IF SQL%FOUND THEN
              DBMS_OUTPUT.PUT_LINE('record deleted successfully');
          ELSE
              DBMS_OUTPUT.PUT_LINE('record not found');
          END IF;
     END;
      /

Enter value for empno: 7844
record deleted successfully

SQL> / 

Enter value for empno: 9090
record not found
 
difference between implicit & explicit cursor  ?

	explicit			implicit

1	declared by user		declared by oracle

2	used to process		used to process output of 
                output of select stmt		dml commands

3	name given by user		name is always SQL


Ex 2  :- 

ACCOUNT
 accno	actype	bal
100	S	10000
101	S	20000

TRANSACTIONS
 trid	ttype	tdate	tamt	accno

CREATE SEQUENCE S10
START WITH 1
INCREMENT BY 1
MAXVALUE 9999;
 
=> wap to process money transfer ? 

 DECLARE
   v_sacno      NUMBER(4);
   v_tacno      NUMBER(4);
   v_amt         NUMBER(5);
   v_bal          NUMBER(7);
   cnt1            NUMBER;
   cnt2            NUMBER;
 BEGIN
     v_sacno := &sacno;      100
     v_tacno  := &tacno;       999
     v_amt   := &amount;     1000
     SELECT bal INTO v_bal FROM accounts WHERE accno = v_sacno ;
     IF v_amt > v_bal THEN
         DBMS_OUTPUT.PUT_LINE('insufficient balance');
    ELSE
         UPDATE accounts SET bal = bal - v_amt WHERE accno = v_sacno ; 
         cnt1 := SQL%ROWCOUNT;
         UPDATE accounts SET bal = bal + v_amt WHERE accno = v_tacno ; 
         cnt2 := SQL%ROWCOUNT;
         INSERT INTO transactions VALUES(s10.nextval,'w',sysdate,v_amt,v_sacno);
         INSERT INTO transactions VALUES(s10.nextval,'d',sysdate,v_amt,v_tacno);
         IF  cnt1=1  AND cnt2=1 THEN
              COMMIT;
              DBMS_OUTPUT.PUT_LINE('transaction successful');
        ELSE
              ROLLBACK;
              DBMS_OUTPUT.PUT_LINE('transaction cancelled');
         END IF;
   END IF;
END;
  /

 NOTE :- 

=> every transaction must gurantee a property called atomocity i.e. all or none, 
 if transaction contains multiple operations , if all operations are successfully completed then
 commit , if one of the operation fails then entire transaction must be cancelled.

=> using implicit cursor we can find individual operations are successful or not .

 summary :- 

 explicit cursor
 for loop
 inline cursor
 for update
 current of 
 ref cursor
 implicit cursor

ERROR HANDLING / EXCEPTION HANDLING :- 
---------------------------------------------------------------------

1  syntax errors
2  logical errors
3  runtime errors  (exceptions)

 => errors that are raised during program execution are called runtime errors 

  ex :-  

    DECLARE
        a  NUMBER(3) ;
    BEGIN
        a := &a;
       DBMS_OUTPUT.PUT_LINE('hello');
   END;
    /
 
   enter value for a :- 1000

 ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error: number precision too large
ORA-06512: at line 4

 => if any statement causes runtime error  then program execution is terminated and
      oracle displays error message  , to terminate program normally and to replace
      system generated message with our own simple and user friendly message then
      we need to handle that runtime error.

 => To handle runtime error then include a block called EXCEPTION block.

      DECLARE
           variables ;
      BEGIN
           statements ;    =>  stmts causes exception
      EXCEPTION
           statements;    =>  stmts handles exception
       END ;
       /

 => if any statement causes runtime error then control is transferred to exception block
      and execute the statements in exception block.

   EXCEPTION
     WHEN EX1 THEN
        statements;
     WHEN EX2 THEN
        statements;
     WHEN --------
 
     WHEN OTHERS THEN
          statements;
  END;
   /

Types of exceptions :- 
-----------------------------

1  system defined
2  user defined 

 system defined errors :- 
 -------------------------------

1 ZERO_DIVIDE                 => raised when we try to divide a number with 0
2 VALUE_ERROR	          =>  raised when value exceeds variable size
3 INVALID_NUMBER         =>  raised when we perform invalid calculation
4  NO_DATA_FOUND        =>  raised when data not found in the table
5  TOO_MANY_ROWS      =>  raised when select stmt returns more than one row
6  DUP_VAL_ON_INDEX  =>  raised when we insert duplicate value into pk column

Ex 1  :- 

 DECLARE
     a   NUMBER(3);
     b   NUMBER(3);
     c   NUMBER(3);
BEGIN
    a  := &a;
    b  := &b;
    c  := a/b;
    DBMS_OUTPUT.PUT_LINE(c);
 EXCEPTION
    WHEN  VALUE_ERROR THEN
         DBMS_OUTPUT.PUT_LINE('value exceeding size');
   WHEN ZERO_DIVIDE THEN
         DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
END;
 /

Enter value for a: 100
Enter value for b: 0

divisor cannot be zero
 
Ex 2 :- 

 => wap to input empno and print name & salary ? 

   DECLARE
      veno               emp.empno%TYPE;
      vename          emp.ename%TYPE;
      vsal                emp.sal%TYPE;
  BEGIN
       veno := &empno;
       SELECT ename,sal INTO vename,vsal FROM emp WHERE empno = veno ;
       DBMS_OUTPUT.PUT_LINE(vename|| '   '||vsal);
  EXCEPTION
        WHEN NO_DATA_FOUND THEN
              DBMS_OUTPUT.PUT_LINE('employee does not exists');
       WHEN VALUE_ERROR THEN
              DBMS_OUTPUT.PUT_LINE('value exceeding size');
        WHEN OTHERS THEN
              DBMS_OUTPUT.PUT_LINE('unknown error');
END;
 /

Enter value for empno: 9090
employee does not exists


Enter value for empno: 999999999999999
value exceeding size

 SQLCODE,SQLERRM :- 
 --------------------------------

 SQLCODE     =>  returns error code 
 SQLERRM     => returns error message

Ex :- 

 CREATE TABLE emp77
 (
   empno  NUMBER(4) PRIMARY KEY,
   ename VARCHAR2(10) NOT NULL,
   sal  NUMBER(7,2) CHECK(sal>=3000)
  );

=> wap to insert data into emp77 table ? 
 
  DECLARE
     veno               emp77.empno%TYPE;
     vename          emp77.ename%TYPE;
     vsal                emp77.sal%TYPE;
 BEGIN
      veno := &empno;
      vename := '&ename';
       vsal := &sal;
      INSERT INTO emp77 VALUES(veno,vename,vsal);
      COMMIT;
EXCEPTION
       WHEN DUP_VAL_ON_INDEX THEN
           DBMS_OUTPUT.PUT_LINE('empno should not be duplicate');
      WHEN OTHERS THEN
            IF SQLCODE = -02290 THEN
                 DBMS_OUTPUT.PUT_LINE('sal >= 3000');
           END IF;
 END;
   /

  2-dec-25 

  USER DEFINED EXCEPTIONS :- 
  ---------------------------------------------

  => errors raised by user are called user defined exceptions
  => user raises exception to stop program execution based on some condition
  => user can raise exception by using

 1   RAISE stmt
 2   RAISE_APPLICATION_ERROR 

 using RAISE stmt :- 
 -----------------------------

                  RAISE  <exception-name>;

            ex :-   RAISE  abc ;

 => exception  "abc" must be declared in declaration part  as 

                  abc   EXCEPTION ; 

Ex  :- 

  DECLARE
     a   NUMBER(3);
     b   NUMBER(3);
     c   NUMBER(3);
     one_divide  EXCEPTION;
BEGIN
    a  := &a;
    b  := &b;
    IF b=1 THEN
          RAISE  one_divide;
    END IF;
    c  := a/b;
    DBMS_OUTPUT.PUT_LINE(c);
 EXCEPTION
    WHEN  VALUE_ERROR THEN
         DBMS_OUTPUT.PUT_LINE('value exceeding size');
   WHEN ZERO_DIVIDE THEN
         DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
   WHEN ONE_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('divisor cannot be one');
END;
 /

using RAISE_APPLICATION_ERROR :-
---------------------------------------------------------

    RAISE_APPLICATION_ERROR(error code,error msg);

                   error code  =>  -20001 to -20999

    difference between raise & raise_application_error  ?

   1  in raise stmt exception is raised by using name but in raise_application_error
       exception is raised by using code

   2   use raise stmt to raise exception and to handle exception and use raise_application_error
         to raise exception and do not want to handle.

Ex 1  :- 

  => wap to input empno and increment sal by specific amount but sunday updates are not
       allowed ? 

    DECLARE
       veno emp.empno%TYPE;
       vamt  NUMBER(6);
    BEGIN
         veno := &empno;
         vamt := &amount;
         IF TO_CHAR(sysdate,'fmday') = 'sunday' THEN
               RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
         END IF;
         UPDATE emp SET sal = sal + vamt WHERE empno = veno;
         COMMIT;
    END;
      /


  d       1                       fm   => format mask  => removes extra spaces 
  dy      sun
  fmday    sunday

Ex 2  :-   money transfer 

DECLARE
   v_sacno      NUMBER(4);
   v_tacno      NUMBER(4);
   v_amt         NUMBER(5);
   v_bal          NUMBER(7); 
   cnt1            NUMBER;
   cnt2              NUMBER;
 BEGIN
     v_sacno := &sacno;      
     v_tacno  := &tacno;      
     v_amt   := &amount;      
     SELECT COUNT(*)  INTO cnt1  FROM  accounts WHERE accno =  v_sacno ; 
     IF cnt1=0 THEN
            RAISE_APPLICATION_ERROR(-20001,'source accout does not exists');
     END IF;
     SELECT COUNT(*)  INTO cnt2  FROM  accounts WHERE accno =  v_tacno ; 
     IF cnt2=0 THEN
            RAISE_APPLICATION_ERROR(-20001,'target accout does not exists');
     END IF;
     SELECT bal INTO v_bal FROM accounts WHERE accno  = v_sacno; 
     IF v_amt > v_bal THEN
          RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
     END IF;
      UPDATE accounts SET bal = bal - v_amt WHERE accno = v_sacno ; 
      UPDATE accounts SET bal = bal + v_amt WHERE accno = v_tacno ; 
       INSERT INTO transactions VALUES(s10.nextval,'w',sysdate,v_amt,v_sacno);
      INSERT INTO transactions VALUES(s10.nextval,'d',sysdate,v_amt,v_tacno);   
END;
  /
 
=========================================================================

Named PL/SQL Blocks :- 
----------------------------------

1  procedures
2  functions
3  packages
4  triggers 

sub-programs :- 
------------------------

1 procedures
2 functions 

Advantages :- 
-------------------

 1   modular programming :-
      ---------------------------------

  =>  with the help of procedures & function we can divide a big pl/sql program into small modules

2    reusability :- 
     -------------------

  => because proc / func created with name  ,so they can be called from another program

3   invoked from front-end application :-
    -------------------------------------------------

  =>  because  proc/func are stored in db , so applications which are connected to db can
        call proc/func

 4 improves performance :- 
    -----------------------------------

   => proc / func  improves performance because they are precompiled i.e. when we create
       proc program is compiled and stored in db and whenever we call proc only execution
        is repeated but not compilation , so this improves performance.

  PROCEDURES :- 
  --------------------------

   => a procedure is a named PL/SQL block that accepts some input performs some action
        on db tables and may or may not returns a value.

   => procedures are created to perform actions like INSERT/UPDATE/DELETE.

   CREATE OR REPLACE PROCEDURE <name>
   (
       parameters if any
   )
 IS
       <variables>
   BEGIN
        statements;
   END;
     /

 parameters :- 
 -------------------

 => we can declare parameters and we can pass values to parameters
 => parameters are 3 types 

 1 IN   (DEFAULT)
 2 OUT
 3 IN OUT

  =>  IN parameter always receives value
  =>  OUT parameter always sends value
 => IN OUT receives and sends 

 
                MAIN				PROC

	X      ------------------------------------------->	A  (IN)

	Y      <--------------------------------------------	B   (OUT)

	 Z     -------------------------------------------->	C   (IN OUT)
                         <---------------------------------------------
  
Ex 1 :- 

  => create procedure to increment all employee salaries by 1000 ?
   
   CREATE OR REPLACE PROCEDURE raise_salary
   IS
   BEGIN
           UPDATE emp SET sal = sal + 1000 ;
           COMMIT;
    END;
        /

  procedure created ( compiled + stored in db)

Execution :-
------------------

 1  sql prompt
 2  another pl/sql prog
 3  front-end

Executing from sql prompt :-
------------------------------------- 
 
 SQL>EXECUTE  raise_salary ; 

Ex 2 :- 

 => create a procedure to increment specific employee sal by specific amount ?

     CREATE  OR REPLACE PROCEDURE raise_salary 
     (
        p_eno  IN  emp.empno%TYPE,
        p_amt IN NUMBER
     )
   IS
   BEGIN
           UPDATE emp SET sal = sal + p_amt WHERE empno = p_eno ; 
           COMMIT;
    END;
        /

 Execution :- 

 SQL>EXECUTE  raise_salary (7788,1000);           positional association

  SQL>EXECUTE raise_salary(p_eno => 7788, p_amt => 1000);  named association

3-dec-25 

Ex 3 :-

 => create  a procedure to increment specific employee sal by specific amount
      and after increment send the updated sal to calling program ?

    CREATE OR REPLACE PROCEDURE raise_salary
    (
       p_eno  IN emp.empno%TYPE,
       p_amt  IN NUMBER,
       p_newsal OUT emp.sal%TYPE
    )
    IS
    BEGIN
        UPDATE emp SET sal = sal + p_amt WHERE empno = p_eno ;
        COMMIT;
        SELECT sal INTO p_newsal  FROM emp WHERE empno = p_eno;
    END;
      /

Execution :-
--------------- 

SQL>VARIABLE K NUMBER
SQL>EXECUTE raise_salary(7499,1000,:K);
SQL>PRINT :K

 note :- 

  => variable declared at sql prompt are called "bind variables" 
  => bind variables are prefixed with ":" operator

 Ex 4 :- 

 => create a procedure that accepts name and returns first name,middle name,last name ?

   CREATE OR REPLACE PROCEDURE getNames
   (
     p_name  IN  VARCHAR2,
     p_fname  OUT VARCHAR2,
     p_mname OUT VARCHAR2,
     p_lname   OUT VARCHAR2
    )
   IS
   BEGIN
         p_fname := REGEXP_SUBSTR(p_name,'[a-z]+',1,1);
         p_mname := REGEXP_SUBSTR(p_name,'[a-z]+',1,2);
         p_lname := REGEXP_SUBSTR(p_name,'[a-z]+',1,3);
    END;
         /

Execution :- 

SQL> VARIABLE F VARCHAR2(20)
SQL> VARIABLE M VARCHAR2(20)
SQL> VARIABLE L VARCHAR2(20)
SQL> EXECUTE getNames('sachin ramesh tendulkar',:F,:M,:L);        

 Ex 4 :- 

=> create a procedure to copy data from custs to custt ?
 
CUSTS				 CUSTT
CID	CNAME			CID	FNAME	MNAME	LNAME
10	sachin ramesh tendulkar
11	mahendra singh dhoni

 CREATE OR REPLACE PROCEDURE copy_custs_custt
 IS
  CURSOR C1 IS SELECT *
                             FROM CUSTS
                             WHERE CID NOT IN (SELECT CID FROM CUSTT);
  f  VARCHAR2(20);
  m  VARCHAR2(20);
  l    VARCHAR2(20);
 BEGIN
     FOR r IN C1
    LOOP
          getNames(r.cname,f,m,l);
          INSERT INTO custt VALUES(r.cid,f,m,l);
     END LOOP;
     COMMIT;
  END;
    /

Ex 5 :- 

 => create a procedure for money withdrawl ? 

ACCOUNT
 accno	actype	bal
100	S	10000
101	S	20000

TRANSACTIONS
 trid	ttype	tdate	tamt	accno

CREATE SEQUENCE S10
START WITH 1
INCREMENT BY 1
MAXVALUE 9999;

 CREATE OR REPLACE PROCEDURE  debit
 (
   p_acno  IN  accounts.accno%TYPE,
   p_amt    IN  NUMBER,
   p_newbal OUT accounts.bal%TYPE
  )
  IS
      v_bal  accounts.bal%TYPE;
      cnt  NUMBER;
  BEGIN
      SELECT COUNT(*) INTO cnt FROM accounts WHERE accno = p_acno ;
      IF cnt=0 THEN
         RAISE_APPLICATION_ERROR(-20001,'account does not exists');
      END IF;
      SELECT bal INTO v_bal FROM accounts WHERE accno = p_acno;
      IF p_amt > v_bal THEN
         RAISE_APPLICATION_ERROR(-20002,'insufficient funds');
      END IF;  
      UPDATE accounts SET bal = bal - p_amt WHERE accno = p_acno;
      INSERT INTO transactions VALUES(s10.nextval,'W',SYSDATE,p_amt,p_acno);
      COMMIT ;
      SELECT bal INTO p_newbal FROM accounts WHERE accno = p_acno;
   END;
     /

 SQL> VARIABLE B NUMBER
SQL> EXECUTE DEBIT(100,1000,:B);

=> create a procedure for money deposit ?
=> create a procedure for money transfer ? 

Ex 6 :- 

 => create a procedure that accepts deptno and returns employees 
      belongs to that dept ?

   CREATE OR REPLACE PROCEDURE getEmpList
   (
       p_dno  IN emp.deptno%TYPE ,
       p_emp  OUT SYS_REFCURSOR
    )
    IS
    BEGIN
       OPEN p_emp  FOR SELECT empno,ename,job,deptno 
                                        FROM emp 
                                        WHERE deptno =  p_dno;
    END;
           /

Execution :- 
 
SQL> VARIABLE C1 REFCURSOR
SQL> EXECUTE getEmpList(20,:C1);

4-DEC-25 

 USER DEFINE FUNCTIONS :- 
 -------------------------------------------

 => functions created by user are called user define functions.

 => when predefine functions not meeting our requirements then we create our own
       functions called user define functions.

 => a function is also a named PL/SQL block that accepts some input perform some
      calculation and must return a value.

 CREATE OR REPLACE FUNCTION <name>
 (
    parameters 
 ) RETURN <type>
 IS
     variables;
 BEGIN
        statements;
        RETURN <expr>;
 END;
   /

Ex 1 :- 

 CREATE OR REPLACE FUNCTION calc
 (
    a  NUMBER, b  NUMBER,op CHAR
 ) RETURN NUMBER
 IS
   c  NUMBER;
 BEGIN
      IF  op='+' THEN
           RETURN (a+b);
     ELSIF op='-' THEN
           RETURN (a-b);
     ELSIF op='*' THEN
           RETURN (a*b);
    ELSE
           RETURN (a/b);
    END IF;
 END;
   /

Execution :- 
---------------

 1  SQL commands
 2  another pl/sql prog
 3  front-end applications

 Executing from sql commands :- 
 ---------------------------------------------

 SELECT CALC(10,20,'*') FROM DUAL ;  => 200

Ex 2 :- 

 => create a function to check whether given year is leap year or not ?

   CREATE OR REPLACE FUNCTION IS_LEAP
   (y    NUMBER) RETURN VARCHAR2
   IS
      d  DATE;
   BEGIN
       d   :=  '29-FEB-'||y;
       RETURN 'leap year';
 EXCEPTION
       WHEN OTHERS THEN
               RETURN 'Not a leap year';
 END;
   /

 SQL>SELECT IS_LEAP(2025) FROM DUAL ;

 Not a leap year

SQL> SELECT IS_LEAP(2024) FROM DUAL ;

leap year
 
 SQL>SELECT ENAME,IS_LEAP(TO_CHAR(HIREDATE,'YYYY')) AS LEAP FROM EMP ;

Ex 3 :- 

  orders					products
  ordid	prodid	qty			prodid	pname	price
  1000	100	2			100	A	1000
  1000	101	3			101	B	1500
  1000	102	1			102	C	2000
  1001	100	2

   create a function to calculate total amount of particular order ? 

              input    :-    ordid  = 1000

              output :-     amount =  8500
             
   CREATE OR REPLACE FUNCTION  getOrdAmt
   (
        p_ordid   orders.ordid%TYPE
   )  RETURN NUMBER
  IS
     CURSOR C1 IS    SELECT  o.prodid,o.qty,p.price
                                  FROM orders o INNER JOIN products p
                                  ON o.prodid = p.prodid
                                  WHERE o.ordid = p_ordid  ;
      v_amt  NUMBER := 0;
  BEGIN
       FOR r IN C1
       LOOP
             v_amt  :=   v_amt  + (r.qty * r.price);
       END LOOP;
       RETURN v_amt ;
 END;
  /

 SQL>SELECT getOrdAmt(1000) FROM DUAL ;    =>  8500

 SQL>SELECT DISTINCT ordid,getOrdAmt(ordid) FROM orders ;

     ORDID  GETORDAMT(ORDID)
    ----------   ----------------
      1001             1000
      1000             8500
 
  Ex 4 :- 

 => create function that return Top N employee list based on sal ? 

  CREATE OR REPLACE 
            FUNCTION getTopN(n   NUMBER)  RETURN  SYS_REFCURSOR
  IS
   C1  SYS_REFCURSOR;
  BEGIN
          OPEN C1 FOR  SELECT empno,ename,sal
                                    FROM emp
                                    ORDER BY sal DESC
                                     FETCH FIRST n ROWS ONLY ;
           RETURN C1;
  END;
    /
    

Execute :-

 SQL>SELECT  getTOpN(5) FROM DUAL ; 

  EMPNO ENAME             SAL
  ----------  ----------           ----------
      7788 SCOTT            8000
      7839 KING               7000
      7499 ALLEN             6000
      7902 FORD              5150
      7698 BLAKE             4850

 => difference between procedures & functions ?

	PROCEDURES			FUNCTIONS

1	may or may not returns a value		must return a value

2	can return multiple values		can return only one value

3	returns value using OUT  parameter	returns value using return stmt

4	cannot be executed from sql commands	can be executed from sql commands

5	dml stmts are allowed in procedures	not recommended in functions

6	created to perform dml operations	created to perform calculations

7	create procedure to update balance	create function to get balance

 => is return stmt is allowed in procedures ? 

     a return stmt in procedure return control to the calling program but cannot return value

 USER_SOURCE :- 
 ---------------------------

 => stores procedures & functions created by user

  NAME		TYPE		LINE		TEXT 
  P1		PROC		1		PROCEDURE P1(E NUMBER)
  P1		PROC		2		IS
  P1		PROC		3		BEGIN
  P1		PROC		4		 UPDATE
				5		 RETURN;
\				6		END;
 
 => list of procedures & functions ? 

    SELECT NAME,TYPE  FROM USER_SOURCE ; 

 => display debit procedure code ? 

    SELECT  TEXT FROM USER_SOURCE WHERE NAME='DEBIT' ; 

 Droping :- 
 -----------

 DROP PROCEDURE P1 ; 
 DROP FUNCTION F1 ;   

How to schedule a stored procedure :-
-----------------------------------------------------

    BEGIN
      DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'JOB1',
        job_type        => 'STORED_PROCEDURE',
        job_action      => 'COPY_CUSTS_CUSTT', -- Replace with your schema and procedure name
        start_date      => SYSTIMESTAMP, -- Or a specific date/time like TO_TIMESTAMP('2025-12-05 15:00:00', 'YYYY-MM-DD HH24:MI:SS')
        repeat_interval => 'FREQ=MINUTELY;INTERVAL=1', -- Example: runs daily at 3 AM
        enabled         => TRUE,
        comments        => 'Job to run my stored procedure for  every 1 min'
      );
    END;
    /

 
 Frequencies :-
 ----------------------

FREQ: The main period (e.g., DAILY, HOURLY, MINUTELY, MONTHLY, YEARLY, WEEKLY).
INTERVAL: A positive integer (default 1) for how often the frequency repeats (e.g., INTERVAL=3 for every 3 days).
BYHOUR, BYMINUTE, BYSECOND: To specify time within a day/hour/minute.
BYDAY: Days of the week (MON, TUE, etc.) or specific occurrences (e.g., 3FRI for the third Friday).
BYMONTH: Months (JAN, FEB, etc.).
BYMONTHDAY: Days of the month (e.g., 15,-1 for the 15th and last day). 

Examples :- 

Every day at 2 AM: FREQ=DAILY; BYHOUR=2.
Every 5 minutes: FREQ=MINUTELY; INTERVAL=5.
Every Monday at 9 AM: FREQ=WEEKLY; BYDAY=MON; BYHOUR=9.
Every hour on the minute: FREQ=HOURLY; BYMINUTE=0.
Twice daily (8 AM & 8 PM): FREQ=DAILY; BYHOUR=8,20 (using a comma-separated list). 

 PACKAGE :- 
 ------------------- 

 =>  package is a collection of procedures,functions,variables,cursor etc.
 =>  related procedure & functions are grouped into one package.
 
Advantages :- 
-------------------

1  easy to manage :- 
 ---------------------------

 => because related procedures & functions available in one package then managing is easy.

2  supports overloading :- 
     -------------------------------

 => standalone procedure & functions doesn't support overloading but package supports
      overloading i.e. in package we can define two or more proc / func with same name with
      different parameters.

 3  supports hiding :-
  -----------------------------

  => package supports hiding , in package we can make proc/func as public and private
       and public members can be called from any application but private members can be
       called with in package and cannot be called from outside package.

 4  improves performance :- 
     ----------------------------------

  =>  when application requests for a proc / func in a package then oracle will not only
        load  requested member but entire package loaded in into memory and next
        requests will not go to db , so no of requests going to db are reduced and performance
        is improved.

=> package contains two parts 

 1 package specification
 2 package body 

 package specification :- 
 -----------------------------------

  => package specification contains declaration of procedures & functions 

 CREATE OR REPLACE PACKAGE <name> 
 AS
   PROCEDURE <name>(parameters) ;
   FUNCTION <name>(parameters) RETURN <type>;
  ------------------------
 END;
  /

package body :-
----------------------

  => package body contains definitions (code) of procedures & functions declared in package
        specification.

  CREATE OR REPLACE PACKAGE BODY <name>
  AS
        PROCEDURE <name>(parameters)
        IS
             -----
        BEGIN
              ---------
        END <proc-name>;
        FUNCTION <name>(parameters) RETURN <type>
        IS
             ---------
        BEGIN
              ----------
              RETURN --
        END <fun-name>;
 END;
  /

Ex 1  :- 

 => create package to implement following actions on emp ?

     1  hire employee (proc)
     2 fire employee   (proc)
     3 increment salary  (proc)
     4 calculate experience (func)
     5 find top n employee (func)

 package specification :-
--------------------------------

  CREATE OR REPLACE PACKAGE hr
  AS
    PROCEDURE hire(e NUMBER,n VARCHAR2,j VARCHAR2,s NUMBER,d NUMBER);
    PROCEDURE fire(e NUMBER);
    PROCEDURE hike(e NUMBER,amt NUMBER);
    FUNCTION expr(e NUMBER) RETURN NUMBER;
    FUNCTION getTopNEmp(n NUMBER) RETURN SYS_REFCURSOR;
  END;
    /

package body :-
-----------------------

 CREATE OR REPLACE PACKAGE BODY hr
 AS
  PROCEDURE  hire(e NUMBER,n VARCHAR2,j VARCHAR2,s NUMBER,d NUMBER)
  IS
  BEGIN
        INSERT INTO emp(empno,ename,job,sal,hiredate,deptno) VALUES(e,n,j,s,sysdate,d);
        COMMIT;
 END hire;
 PROCEDURE fire(e NUMBER) 
 IS
 BEGIN
        DELETE FROM emp WHERE empno = e;
        COMMIT;
 END fire;
 PROCEDURE hike(e NUMBER,amt NUMBER)
 IS
BEGIN
      UPDATE emp SET sal = sal + amt WHERE empno = e;
      COMMIT;
 END hike;
 FUNCTION expr(e NUMBER) RETURN NUMBER
 IS
    vexpr NUMBER;
 BEGIN
    SELECT   (SYSDATE-hiredate) / 365  INTO vexpr FROM emp WHERE empno = e;
    RETURN vexpr;
 END expr;
 FUNCTION getTopNEmp(n NUMBER) RETURN SYS_REFCURSOR
 IS
    C1   SYS_REFCURSOR;
BEGIN
    OPEN C1 FOR SELECT *
                             FROM emp 
                             ORDER BY sal DESC
                              FETCH FIRST n ROWS ONLY ;
   RETURN C1 ;
END getTopNEmp;
END;
  /

Execution :-
------------------

   PACKAGENAME.MEMBER(parameters) ;

 Ex :- 

 Ex 2 :- 


ACCOUNT
 accno	actype	bal
100	S	10000
101	S	20000

TRANSACTIONS
 trid	ttype	tdate	tamt	accno


CREATE SEQUENCE S10
START WITH 1
INCREMENT BY 1
MAXVALUE 9999;

=> create a package to implement following bank transactions ? 

 1 account opening (proc)
 2 account closing (proc)
 3 balance enquir  (func)
 4 money deposit  (proc)
 5 money withdrawl (proc)
 6 money transfer (proc)
 7 statement between two given dates  (func)
 8 lastest N transactions of particular customer (func)

 CREATE OR REPLACE PACKAGE bank
 AS
  PROCEDURE  open_acct(a NUMBER,t CHAR,b NUMBER);
  PROCEDURE  close_acct(a NUMBER);
  FUNCTION getBal(a NUMBER) RETURN NUMBER;
  PROCEDURE credit(a NUMBER,amt NUMBER);
  PROCEDURE debit(a NUMBER,amt NUMBER);
  PROCEDURE transfer(s NUMBER,t NUMBER,amt NUMBER);
  FUNCTION getStmt(a NUMBER,s DATE,e DATE) RETURN SYS_REFCURSOR;
  FUNCTION getStmt(a NUMBER,n NUMBER) RETURN SYS_REFCURSOR;
 END;
  /

 CREATE OR REPLACE PACKAGE BODY  bank
AS
PROCEDURE  open_acct(a NUMBER,t CHAR,b NUMBER)
IS
BEGIN
     INSERT INTO accounts VALUES(a,t,b);
     COMMIT;
END open_acct;
PROCEDURE  close_acct(a NUMBER)
IS
BEGIN
     DELETE FROM accounts WHERE accno = a;
     COMMIT;
END close_acct ;
FUNCTION getBal(a NUMBER) RETURN NUMBER
IS
 vbal NUMBER;
BEGIN
      SELECT bal INTO vbal FROM accounts WHERE accno = a ;
      RETURN vbal;
END getBal;
PROCEDURE credit(a NUMBER,amt NUMBER)
IS
BEGIN
    UPDATE accounts SET bal = bal + amt WHERE accno = a;
    INSERT INTO transactions VALUES(s10.nextval,'D',sysdate,amt,a);
   COMMIT;
END credit;
PROCEDURE debit(a NUMBER,amt NUMBER)
IS
vbal NUMBER;
BEGIN
     vbal :=    getBal(a) ; 
     IF  amt > vbal THEN
           RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
     END IF;
    UPDATE accounts SET bal = bal - amt WHERE accno = a;
    INSERT INTO transactions VALUES(s10.nextval,'W',sysdate,amt,a);
   COMMIT;
END debit;
PROCEDURE transfer(s NUMBER,t NUMBER,amt NUMBER)
IS
BEGIN
   debit(s,amt);
   credit(t,amt);
 END transfer;
  FUNCTION getStmt(a NUMBER,s DATE,e DATE) RETURN SYS_REFCURSOR
  IS 
     C1  SYS_REFCURSOR;
  BEGIN 
      OPEN C1 FOR  SELECT *
                                FROM transactions  
                                WHERE accno = a
                                              AND
                                             tdate BETWEEN  s AND  e ;
     RETURN C1;
 END getStmt;
 FUNCTION getStmt(a NUMBER,n NUMBER) RETURN SYS_REFCURSOR
 IS
     C1  SYS_REFCURSOR;
  BEGIN
     OPEN C1 FOR  SELECT *
                                FROM transactions
                                WHERE accno = a 
                                ORDER BY tdate DESC
                                FETCH FIRST n ROWS ONLY ; 
      RETURN C1;
  END getStmt;
END;
 /

Execution :- 
-----------------

SQL>  EXECUTE bank.open_acct(100,'S',10000);
SQL>  EXECUTE bank.debit(100,2000); 
SQL>  EXECUTE BANK.CREDIT(100,5000);
SQL>  SELECT BANK.GETSTMT(100,3) FROM DUAL ;
SQL>  SELECT BANK.GETSTMT(100,SYSDATE-1,SYSDATE) FROM DUAL ;
 
verify tables :- 

 SQL>SELECT * FROM accounts ;

 SQL>SELECT * FROM transactions ;

Droping :- 
--------------

 SQL>DROP PACKAGE HR ;   => drop package specification and body 

 SQL>DROP PACKAGE BODY BANK ;  => drops only body but not specification

 
DBMS_OUTPUT 
DBMS_SCHEDULER
UTL_FILE
DBMS_LOB

 UTL_FILE package :-
-------------------------------

 => a predefined package used to work with files
 => using this package users can create new files,write data into files and read data from files.
 
 members of UTL_FILE package :-
 ------------------------------------------------

1 FILE_TYPE    => It is a datatype 
2 FOPEN          =>  It is a function used to open file
3 PUT_LINE     =>  It is a procedure used to write data into file
4 GET_LINE     =>  It is a procedure used to read data from file
5 FCLOSE        =>  It is a procedure used to close file


 File Modes :-
 ------------------

 W  => write mode  => to create new file and write data 
 R  => read mode   => to read data from existing file
 A  => append mode  => to add data to existing file

 Directory Object :- 
 -------------------------

  => It is an object in database that points to operating system folder
  => created by dba and granted to users

 SYSTEM :-
 ---------------

 SQL> CREATE DIRECTORY D99 AS 'D:\NARESH' ;
 SQL> GRANT READ,WRITE ON DIRECTORY D99 TO BATCH53 ;
 
BATCH53 :-
-----------------

=> wap to create new file and write data ? 

  DECLARE
        f1    UTL_FILE.FILE_TYPE;
 BEGIN
       f1   :=    UTL_FILE.FOPEN('D99','abc.txt','W');
       UTL_FILE.PUT_LINE(f1 , 'hello');
       UTL_FILE.PUT_LINE(f1 , 'welcome');
       UTL_FILE.PUT_LINE(f1 , 'utl_file package');
       UTL_FILE.FCLOSE(f1);
 END;
   /
 

=> wap to read data from file ? 

 DECLARE
        f1    UTL_FILE.FILE_TYPE; 
        s     VARCHAR2(1000);
 BEGIN
       f1   :=    UTL_FILE.FOPEN('D99','abc.txt','R');
     LOOP
          UTL_FILE.GET_LINE(f1,s);
          DBMS_OUTPUT.PUT_LINE(s);
    END LOOP;
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   UTL_FILE.FCLOSE(f1);
   END;
     /
 
 => wap to copy data from emp table to file ? 
 
 CREATE OR REPLACE PROCEDURE copy_emp_text_file
 IS
    CURSOR C1 IS SELECT empno,ename,sal,hiredate FROM emp;
    f1  UTL_FILE.FILE_TYPE;
    s   VARCHAR2(1000);
 BEGIN
     f1 := UTL_FILE.FOPEN('D99','emp.txt','w');
     FOR r IN C1
     LOOP
           s   :=   r.empno||','||r.ename||','||r.sal||','||r.hiredate;
           UTL_FILE.PUT_LINE(f1,s);
      END LOOP;
       UTL_FILE.FCLOSE(f1);
  END;
     /
    
CREATE OR REPLACE PROCEDURE copy_emp_csv_file
 IS
    CURSOR C1 IS SELECT empno,ename,sal,hiredate FROM emp;
    f1  UTL_FILE.FILE_TYPE;
    s   VARCHAR2(1000);
 BEGIN
     f1 := UTL_FILE.FOPEN('D99','emp.csv','w');
     FOR r IN C1
     LOOP
           s   :=   r.empno||','||r.ename||','||r.sal||','||r.hiredate;
           UTL_FILE.PUT_LINE(f1,s);
      END LOOP;
       UTL_FILE.FCLOSE(f1);
  END;
     /

8-dec-25

=> wap to copy data from csv file to oracle table ? 

 source :-  D:\naresh\emp.csv

 target :- 

 CREATE TABLE emp77
   (
      empno NUMBER(4),
     ename VARCHAR2(10),
     sal  NUMBER(8),
      hiredate DATE
     );

 CREATE OR REPLACE PROCEDURE copy_csv_emp 
(
   f  IN  VARCHAR2
 )
 IS
    f1  UTL_FILE.FILE_TYPE;
    s   VARCHAR2(1000);
    veno NUMBER(4);
    vename VARCHAR2(10);
    vsal  NUMBER(8);
    vhire  DATE;
 BEGIN
      f1 :=  UTL_FILE.FOPEN('D99',f,'r');
    LOOP
         UTL_FILE.GET_LINE(f1,s);      	  
         veno      := REGEXP_SUBSTR(s,'[^,]+',1,1);
         vename := REGEXP_SUBSTR(s,'[^,]+',1,2);
         vsal       :=  REGEXP_SUBSTR(s,'[^,]+',1,3);
         vhire      := REGEXP_SUBSTR(s,'[^,]+',1,4);
         INSERT INTO emp77 VALUES(veno,vename,vsal,vhire);
   END LOOP;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
                 UTL_FILE.FCLOSE(f1);
   END;
    /

 ==========================================================================

  TRIGGERS :- 
  -------------------

 => a trigger is also a named PL/SQL Block like procedure but executed implicitly by oracle
      whenever user executes DML / DDL commands.

 => triggers are created 

  1  to control dmls 
  2  to enforce  complex rules and validations
  3  to audit day-to-day opeations on tables 
 
CREATE OR REPLACE TRIGGER <name>
BEFORE / AFTER INSERT OR UPDATE OR DELETE
ON <tabname>
[FOR EACH ROW]
[
   DECLARE
       variables
]
BEGIN
       statements;
END;
 /

 BEFORE triggers :- 
 ---------------------------

  => if trigger is before then oracle executes the trigger before executing dml
  
 1 trigger 
 2 dml

 AFTER triggers :-
 -------------------------

  => if trigger is after then oracle executes the trigger after executing dml

 1  dml
 2  trigger

 Trigger  levels :- 
 -----------------------

 1  statement level
 2  row level 
 
=> statement level triggers are executed once per the stmt and irrespective of number of rows
     affected by dml

 => row level triggers are executed once per the row affected by dml

 => declare FOR EACH ROW to create row level triggers

 Ex 1 :- 

 => create trigger to not to allow dmls on emp table on sunday ?

      CREATE OR REPLACE TRIGGER TRG1
      BEFORE INSERT OR UPDATE OR DELETE
      ON emp
      BEGIN
             IF TO_CHAR(SYSDATE,'fmday') = 'sunday' THEN
                  RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
             END IF;
       END;
         /

Testing :- 
--------------

      UPDATE EMP  SET SAL = 3000  WHERE EMPNO = 7369 ;    => error

 Ex 2  :-  create trigger to not to allow dmls as follows ?

               mon - fri   <10am and >4pm
               sat           <10am and >2pm
               sun           ---------------------

      CREATE OR REPLACE TRIGGER TRG2
      BEFORE INSERT OR UPDATE OR DELETE
      ON emp 
      BEGIN
           IF  TO_CHAR(SYSDATE,'d') BETWEEN 2 AND 6  THEN
                IF TO_CHAR(SYSDATE,'HH24') < 10  OR TO_CHAR(SYSDATE,'HH24') >= 16 THEN
                      RAISE_APPLICATION_ERROR(-20001,'only between 10am and 4pm');
               END IF;
          ELSIF TO_CHAR(SYSDATE,'dy') = 'sat' THEN
                IF TO_CHAR(SYSDATE,'HH24') < 10  OR TO_CHAR(SYSDATE,'HH24') >= 14 THEN
                      RAISE_APPLICATION_ERROR(-20001,'only between 10am and 2pm');
                END IF;
          ELSE
                 RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
            END IF;
      END;
     /

   Testing :- 
   --------------

   UPDATE EMP SET SAL = 2000 WHERE EMPNO = 7369 ;


               mon - fri   <10am and >4pm

               sat           2,4   not allowed
                              1,3   <10am and >2pm

               sun           ---------------------

 
 Ex 3  :- 

 =>  create trigger to not to allow to update empno ? 

      CREATE OR REPLACE TRIGGER TRG3
      BEFORE UPDATE  OF EMPNO,HIREDATE
      ON emp 
      BEGIN
            RAISE_APPLICATION_ERROR(-20002,'cannot update empno , hiredate') ;
      END;
         /

Testing :- 
-------------

   UPDATE emp SET empno = 9999 WHERE empno = 7369  ; 

9-dec-25

:NEW & :OLD variables :- 
------------------------------------

  => these two variables are called  bind variables and rowtype variables
  => record affected by dml is copied to these two variables
  => record user is trying to insert is copied to :NEW
  => record user is trying to delete is copied to :OLD
  => record user is trying to update is copied to both :OLD & :NEW.

  insert into emp values (100,'A','clerk',3000,----20);    =>  :NEW 
  
  delete from emp where empno = 7369   =>   :OLD

   update emp set sal = 1000 where empno = 7369 ;  =>    :OLD
					          empno	sal
					          7369	800

					          :NEW
					           empno	sal
					           7369	1000

 => these two variables are allowed only in row level trigger but not allowed in stmt level triggers

 Ex 4 :- 

 => create trigger to not to allow to decrement salary ? 

 CREATE OR REPLACE TRIGGER TRG4
 BEFORE UPDATE
 ON EMP
 FOR EACH ROW
 BEGIN
        IF  :OLD.SAL  >  :NEW.SAL THEN
              RAISE_APPLICATION_ERROR(-20001,'sal cannot be decremented');
        END IF;
  END;   
    / 

Testing :- 
 -----------

 UPDATE emp SET sal = 1000 WHERE empno = 7788 ; 
 
 /* 

   1   row is copied  :old , :new variables
   2   executes trigger
   3   executes dml
 
*/


Ex 5 :- 

=> create trigger to insert details into emp_old table whenever employee resigns ?

 EMP_OLD
 EMPNO	   ENAME     JOB     SAL    HIREDATE 	DOR

CREATE TABLE emp_old
 (
 empno NUMBER(4),
  ename VARCHAR2(10),
  job  VARCHAR2(10),
  sal   NUMBER(8),
  hiredate DATE,
  dor  DATE
 )

CREATE OR REPLACE TRIGGER TRG5
AFTER DELETE
ON EMP
FOR EACH ROW
BEGIN
    INSERT INTO emp_old 
         VALUES(:old.empno,:old.ename,:old.job,:old.sal,:old.hiredate,sysdate);
END;
  /



Testing :-
-------------

1  DELETE FROM emp WHERE empno = 7369 ; 

 /*

 1 row is copied to :old variable
 2 row is deleted
 3 trigger is executed 

 */

2  DELETE FROM emp WHERE empno IN (7499,7521); 


 1  7499 row is copied to :old
 2  row is deleted
 3  trigger is executed 

 1  7521 row is copied to :old
 2  row is deleted
 3  trigger is executed 

Ex 6 :- 

=> create trigger to manage replica ? 

 CUSTS					CUSTT
 CID	CNAME	CITY			CID	CNAME	CITY
 

 CREATE OR  REPLACE TRIGGER TRG6
 AFTER  INSERT OR UPDATE OR DELETE
 ON CUSTS
 FOR EACH ROW
 BEGIN
         IF INSERTING THEN
                INSERT INTO CUSTT VALUES(:NEW.CID,:NEW.CNAME,:NEW.CITY);
         ELSIF DELETING THEN
                DELETE FROM CUSTT WHERE CID = :OLD.CID ;
         ELSE
                UPDATE CUSTT SET CITY = :NEW.CITY WHERE CID = :OLD.CID ;
         END IF;
 END;
  /


INSERTING   => TRUE  => if operation is insert
UPDATING    => TRUE => if operation is update
DELETING    =>  TRUE => if operation is deleted

Testing :- 
------------

STEP 1 :-

  INSERT INTO CUSTS VALUES(100,'A','HYD') ; 
  DELETE FROM CUSTS WHERE CID = 100
  UPDATE CUSTS SET CITY='BLR' WHERE CID = 100;

STEP 2 :- 

 SELECT * FROM CUSTT ;


Auditing :- 
---------------

  => triggers are also created for auditing  
  => auditing means monitoring day-to-day activities on tables
  => audit information is maintained in tables called audit tables

Ex :- 

=> create trigger to insert details into emp_audit whenever user insert,update,delete on emp ?

 EMP_AUDIT
 uname   operation    optime   new_eno    new_ename   new_sal    old_eno   old_ename   old_sal
 
CREATE  TABLE EMP_AUDIT
(
  uname VARCHAR2(10),
  operation VARCHAR2(10),
  optime     TIMESTAMP,
  new_eno  NUMBER(4),
  new_ename VARCHAR2(10),
  new_sal    NUMBER(7) ,
  old_eno  NUMBER(4),
  old_ename VARCHAR2(10),
  old_sal    NUMBER(7) 
 );

CREATE OR REPLACE TRIGGER TRG7
AFTER INSERT OR UPDATE OR DELETE
ON EMP
FOR EACH ROW
DECLARE
         OP  VARCHAR2(10);
 BEGIN 
       IF  INSERTING THEN
             OP := 'INSERT' ;
       ELSIF DELETING THEN
              OP := 'DELETE';
       ELSE
             OP := 'UPDATE';
      END IF;
      INSERT INTO emp_audit 
              VALUES(user,OP,systimestamp,:new.empno,:new.ename,:new.sal,
                                                                  :old.empno,:old.ename,:old.sal);
  END;
  /

Testing :-
-------------

1   INSERT INTO EMP(EMPNO,ENAME,SAL) VALUES(999,'KKK',4000);
2   UPDATE EMP SET SAL=5000 WHERE EMPNO = 999; 
3    DELETE FROM EMP WHERE EMPNO = 999;

SELECT * FROM EMP_AUDIT ;

psuedo columns / system variables :- 
------------------------------------------------------

1   SYSDATE
 2  SYSTIMESTAMP
 3  ROWID
 4  ROWNUM
 5  LEVEL
 6  USER

 How many triggers can be created on table ?

 ans :- 12

what is order of execution of triggers ?

 before stmt
 before row
 after row
 after stmt

CREATE OR REPLACE TRIGGER T8
BEFORE UPDATE
ON EMP
BEGIN
   DBMS_OUTPUT.PUT_LINE('before stmt');
END;
 /

CREATE OR REPLACE TRIGGER T9
BEFORE UPDATE
ON EMP
 FOR EACH ROW
BEGIN
   DBMS_OUTPUT.PUT_LINE('before row');
END;
 /

CREATE OR REPLACE TRIGGER T10
AFTER UPDATE
ON EMP
FOR EACH ROW
BEGIN
   DBMS_OUTPUT.PUT_LINE('after row');
END;
 /


CREATE OR REPLACE TRIGGER T11 
AFTER UPDATE
ON EMP
BEGIN
   DBMS_OUTPUT.PUT_LINE('after stmt');
END;
 /

Testing :- 


 UPDATE EMP SET SAL = 2000 WHERE EMPNO IN (7369,7499);

output :- 

before stmt
before row
after row
before row
after row
after stmt

2 rows updated.
before stmt
before row
after row
before row
after row
after stmt

Compound Trigger :- 
-----------------------------

 => using compound trigger we can define multiple triggers in one trigger

 CREATE OR REPLACE TRIGGER T12
 FOR UPDATE
 ON emp
 COMPOUND TRIGGER
 
  BEFORE STATEMENT IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('before stmt');
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
        DBMS_OUTPUT.PUT_LINE('before row');
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
      DBMS_OUTPUT.PUT_LINE('afte row');
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
       DBMS_OUTPUT.PUT_LINE('after stmt');
  END AFTER STATEMENT;
END ;
  /

=> list of triggers created by user ? 

     SELECT TRIGGER_NAME,TRIGGER_TYPE,TRIGGERING_EVENT
     FROM USER_TRIGGERS ;

  Droping :- 
  ----------------

   DROP TRIGGER TRG1 ; 

 if we drop table what about triggers created on table ?

 ans :-  triggers are also dropped

 SERVER
      DATABASE
                  USER
                          TABLES
                                ROWS 
                                CONSTRAINTS
                                INDEXES
                                TRIGGERS
                           VIEWS
                           SYNONYMS
                           SEQUENCES
                           M.VIEWS
                           PROCEDURES
                           FUNCTIONS
                           PACKAGES
 
10-dec-25 

 Dynamic SQL :- 
 -----------------------

  => SQL commands generated at runtime are called dynamic sql commands 

      ex :-  DROP TABLE emp    (static sql)

 
               tname   VARCHAR2(20) ;
               tname := '&tabname' ; 
               DROP TABLE  tname  ;   (dynamic sql)

  => Dynamic SQL is useful when we don't know table names and column names until runtime.
  => Dynamic SQL & DDL commands are executed by using EXECUTE IMMEDIATE.

                   EXECUTE IMMEDIATE   'Dynamic  SQL / DDL command'

  => Dynamic SQL / DDL  command should be passed as a string to EXECUTE IMMEDIATE.

Ex 1 :-   create a procedure to drop table ? 

  CREATE OR REPLACE PROCEDURE DROP_TABLE
  (
      tname IN  VARCHAR2
   )
  IS
  BEGIN
         EXECUTE IMMEDIATE   'DROP TABLE  ' || tname ; 
 END;
   /
  
Execute :- 

 SQL>EXECUTE  DROP_TABLE('emp_old');


Ex 2 :- create a procedure to drop all tables ? 

   CREATE OR REPLACE PROCEDURE DROP_ALL_TABLES
   IS 
    CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES
                               MINUS
                               SELECT MVIEW_NAME FROM USER_MVIEWS ;
  BEGIN 
       FOR R IN C1
       LOOP
             EXECUTE IMMEDIATE  ' DROP  TABLE  ' || R.TABLE_NAME || ' CASCADE CONSTRAINTS ' ;
      END LOOP;
   END;
     /

Execution :- 
 
SQL>EXECUTE DROP_ALL_TABLES ;

 Ex 3 :- 

  => wap  display no of rows in all tables ? 

 
OUTPUT :- 
 
EMP	14
DEPT	4
CUST	10

DECLARE
  CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES ;
  s  VARCHAR2(500);
  cnt  NUMBER;
BEGIN
  FOR R IN C1
  LOOP
          s :=  'SELECT COUNT(*) FROM '||R.TABLE_NAME ; 
          EXECUTE IMMEDIATE  s  INTO cnt;
          DBMS_OUTPUT.PUT_LINE(R.TABLE_NAME||'    '||cnt);
  END LOOP;
END;
 / 
 
==============================================================================

How to store multimedia objects in db :- 
------------------------------------------------------

1 BFILE
2 BLOB 

BILE  :- 
----------
 
 => BFILE stands for binary file lob
 => BFILE is called external lob 
 => lob (multimedia object) stored outside db but db stores path called locator
 => to store locator in db use function BFILENAME

               BFILENAME(dir obj,path)

Ex :- 
 
CREATE TABLE cust
(
 cid NUMBER(2),
 cname VARCHAR2(10),
 cphoto BFILE
);

 INSERT INTO cust VALUES(10,'A',BFILENAME('D99','cat.jfif'));

BLOB :- 
-----------

 =>  BLOB stands for binary large object
 =>  BLOB is called internal lob because lob stored inside db.
 => To convert image into binary use package DBMS_LOB.

 ex :- 

CREATE TABLE cust
(
 cid NUMBER(2),
 cname VARCHAR2(10),
 cphoto BLOB
);

INSERT INTO cust VALUES(10,'A',EMPTY_BLOB());

=> create a procedure to update customer photo ? 
 
 CREATE OR REPLACE PROCEDURE update_cust_photo
 (
    d  IN  NUMBER,
    f  IN  VARCHAR2
  )
 IS
     s  BFILE;
     t  BLOB;
     x  NUMBER;
  BEGIN
      SELECT  cphoto INTO t FROM cust WHERE cid = d  FOR UPDATE ; 
      s  := BFILENAME('D99',f);
      DBMS_LOB.OPEN(s,DBMS_LOB.LOB_READONLY);
      x := DBMS_LOB.GETLENGTH(s);
      DBMS_LOB.LOADFROMFILE(t,s,x);
      UPDATE cust SET cphoto = t WHERE cid = d ;
      COMMIT;
      DBMS_LOB.CLOSE(s);
 END;
  /

Execution :- 

SQL> SELECT LENGTH(CPHOTO) FROM CUST WHERE CID=10;

LENGTH(CPHOTO)
--------------
             0

SQL> EXECUTE UPDATE_CUST_PHOTO(10,'cat.jfif');

SQL> select length(cphoto) from cust where cid=10;

LENGTH(CPHOTO)
---------------------------
          4851

==========================================================================

Normalization :- 
----------------------

  => Normalization is process of decomposing table with redundency into number of well structured tables.
  => Normalization process reduces redundency
 
       	    OLTP                  		 		OLAP
    	     
    1	  db is optimized for insert,update,delete		db is optimized for select (read)

    2	 tables are normalized			tables are denormalized

   
 => Normalization process is set of rules and each rule is called one normal form.

  1NF
  2NF
  3NF
  BCNF (boyce-codd NF)
  4NF
  5NF

Ex :- 

  BILL
  billno	bdate	ccode	cname	addr	icode	name	rate	qty	value	tbill
  1000	15-12-25	100	a	hyd	10
  1000	15-12-25   100	a	hyd	11
					12

					20
 
			 
=> above table contains redundency and it leads to anamolies (insert anamoly,update anamoly,
     delete anamoly)  , so to reduce this redundency apply normalization process on the table.

 1NF :- 
 ---------

  => a table said to be in 1NF

     =>  if there are no multivalued attributes 
     =>  if there are no repeating groups in it
     =>  all attributes in atable are atomic (single).

  BILL
  billno	bdate	ccode	cname	addr	icode	name	rate	qty	value	tbill
  s            s                s                s             s                m	m	m	m	m	s
 
 => above table contains multi-valued attributes , so table is not according to 1NF
      then decompose the table into multiple tables and establish relationship by  
      using fk and identity primary key.

  BILL
  billno	bdate	ccode	cname	addr	tbill
 ----------
  1000
  1001
  
 BILL_ITMES
 billno   icode	name	rate	qty	value
------------------
 1000   10		A	60
 1000   11
 1000   12
 1001   10		A	60
 1001   11

 => In the above table if icode is repeated then name,rate are also repeated  , so to reduce
      this redundency apply 2NF.

 2NF :- 
 ---------

 => a table said to be in 2NF

  1   if it is in 1NF
  2   if there are no partial dependencies in it

 
Full Dependency :-
--------------------------

  => if non key fields depends on key field then it is called full dependency

   R(A,B,C,D)        A  => pk

     A  ------>  B,C,D

 ex :-    accno  -----> bal   (full dependency)

Partial dependency :-
------------------------------

 => In table if non key fields depends on part of the key field then it is called partial depedency

   R(A,B,C,D)     A,B    =>  pk 

   A,B   ----->  C   (full dependency)

       B  -------->  D  (partial dependency)

TABLE 1 :- 
-----------------

  BILL
  billno	bdate	ccode	cname	addr	tbill
 ----------
  1000
  1001

=> above table satisifies 2NF because no composite primary key and 
     no partial dependencies exists in the table
  
TABLE 2 :-
---------------

 BILL_ITMES
 billno   icode	name	rate	qty	value
------------------
 1000   10		A	60	3	180
 1000   11
 1000   12
 1001   10		A	60
 1001   11

  billno,icode  ------------->  qty , value   (full dependency)
           icode  -------------->  name,rate   (partial dependency)

 => above table contains partial dependency , so the table is not according to 2NF
      then decompose the table as follows .

 TABLE 2 :- 
 ---------------
 
 ITEMS
 icode	name	rate
 --------

TABLE 3 :-
--------------

 BILL_ITEMS
 billno	icode	qty	value
 ---------------------

3NF :-
---------

 => a table said to be in 3NF

  1  if it is in 2NF
  2  if there are no transitive dependencies in it
  3  derived attributes can be permanently removed from table

 Transitive dependency :-
 ------------------------------------

 => if non key field depends on another non key field then it is called transitive dependency

 R(A,B,C,D)     A  => pk

  A --------> B,C   (full dependency)

  C  -------> D     (transitive dependency)


TABLE 1 :- 
-----------------

  BILL
  billno	bdate	ccode	cname	addr	tbill
 ----------
  1000
  1001

   billno -----------> bdate , tbill  (full) 
   ccode ----------> cname,addr (transitive dependency)
 
 above table contains transitive dependency , so the table is not according to 3nf then
 decompose the table as follows 


 CUST
 ccode	cname	addr     
 --------

BILL
billno	bdate	tbill (derived attribute)     ccode (fk)
--------

TABLE 2 :-
---------------

 ITEMS
 icode 	name	rate
---------

 TABLE 3 :-
---------------

 BILL_ITEMS
 billno	icode	qty	value (derived attribute)
 ---------------------
  
AFTER 3NF :-
------------------

 CUST
 ccode	cname	addr     
 --------

 BILL
 billno	bdate     ccode (fk)
 --------


 ITEMS
 icode 	name	rate
---------


 BILL_ITEMS
 billno	icode	qty	 
 ---------------------

EXISTS operator :-
---------------------------

 => operator used to check whether record exists or not 
 
   SELECT columns
   FROM tabname
   WHERE  colname  EXISTS  (SELECT stmt) ;

 => EXISTS returns TRUE/FALSE
 => if sub-query returns atleast one row then EXISTS returns TRUE
 => if sub-query returns 0 rows then EXISTS returns FALSE.

Ex :- 

 DEPT
 deptno	dname
 10	ACCT
 20	RESEARCH
 30	SALES
 40	OPERATIONS

EMP
empno	ename	job	sal	deptno
1				10
2				20
3				30
4				10

=> display departments which are not empty ?
		
  SELECT *
  FROM dept d
  WHERE EXISTS (SELECT 1 FROM emp WHERE deptno =  d.deptno) 

  DEPT
 deptno	dname
 10	ACCT                 EXISTS (2 rows)   TRUE
 20	RESEARCH       EXISTS (1 row)      TRUE
 30	SALES               EXISTS (1 row)      TRUE
 40	OPERATIONS    EXISTS (0 row)      FALSE

using IN operator :-
---------------------------

 SELECT *
 FROM dept 
 WHERE deptno IN (SELECT deptno FROM emp)
		--------------------------------------
		10
		20
		30

=> oracle recommends EXISTS operator than IN operator  because EXISTS gives good
     performance than IN operator.

NOT EXISTS :-
----------------------

 
   SELECT columns
   FROM tabname
   WHERE  colname  NOT EXISTS  (SELECT stmt) ;

=> returns TRUE if inner query returns no rows
=> returns FALSE if inner query returns atleast one row

Ex :- 

 => display departments which are empty ?

 
  SELECT *
  FROM dept d
  WHERE NOT EXISTS (SELECT 1 FROM emp WHERE deptno =  d.deptno)  ;

 SELECT *
 FROM dept 
 WHERE deptno NOT IN (SELECT deptno FROM emp) ;

 => oracle recommends NOT EXISTS than NOT IN operator

16-dec-25 

 ACID properties :- 
---------------------------

  A   atomocity
 C   consistency
  I    isolation
 D   durability

Atomocity :- 
---------------

 => Every transaction must gurantee a property called atomocity i.e. all or none. If
      transaction contain multiple operations , if all operations are successful then it 
      must be committed , if one of the operation fails then entire  transaction must be 
      rolledback.

  Ex :-	money  transfer

	  acct1	 -----------------1000-------------------------->	acct2
                   bal = 10000                                                               bal = 20000

	 update1					update2
                  (bal = bal - 1000)				(bal = bal + 1000)

                  write ( 9000)				write ( 21000)

   => In above transaction , if both updates are successful then commit the transaction ,
        if one of update fails then entire transaction must be cancelled.

 
      update1
      cnt1 = sql%rowcount 
      update2 
      cnt2 = sql%rowcount
      
       if cnt1=1 and cnt2=1 then
            commit
      else
           rollback

 Consistency :-
 ---------------------

  => db state must be consistent before and after the transaction.

  Ex :- 

   =>   Total balance before transaction    =   30000
          Total balance after transaction      =   30000

Isolation :- 
----------------

  => Isolation ensures that transactions run independently   i.e. one transaction
        should interfere into another transaction .Changes made by one transaction 
        are not visible to others until they are committed.

  Ex :- 
                     SYSTEM				BATCH53

1	     UPDATE BATCH53.EMP      	                UPDATE EMP
	     SET SAL=3000				SET SAL=4000
                      WHERE EMPNO = 7844;			WHERE EMPNO=7844;

	     1 ROW UPDATED + LOCKED		----------WAIT-------------


2	     COMMIT;				1 ROW UPDATED


Durability :- 
-------------------

  => Durability ensures that once a transaction is committed, its changes are permanently saved
      even if the system fails. The data is stored in non-volatile memory, so the database can 
      recover to its last committed state without losing data.

==========================================================================

    
				MongoDB
                                                                  ========

  => MongoDB is a no-SQL Database.

  => no-SQL Databases are non relational databases which are used for storing
       structured,semi structured and unstructured data.

     difference between  SQL   &   NO-SQL  ?

	SQL				No-SQL
 
1	language used for storing,		 used for
                updating,deleting,retrieving		storing ,updating,deleteing,
                data stored in relational		retrieving data stored in non relational db
                databases		

2	Declarative language or		declarative language is absent in no-sql
                 non-procedural language		databases 

3 	vertically scalable			horizontally scalable

4	ACID is guranteed			ACID is not guranteed or 
					eventually consistent

 5	complex searches and transactions 	best for social media  
               involving many rows are best 		and data analytics applications
               suited for SQL.
 
 6	oracle,sql sever,mysql		mongodb,redis,cassandra


		
                 ORACLE				Mongo-DB
 
 	Database				Database

	Tables				Collections

	Rows				Documents

	Columns	Values			Key Value pair			 

 
 ORACLE                                                MONGODB

 SERVER                                                       Connection
    DATABASE                                                        Database
             TABLE                                                              collection
                  ROWS                                                              documets
 	        field values                                                         key-value pair
 

Database command :-
--------------------------------

 => command to see the list of databases ?

    > show databases 

 => command create our own database ?
 
     > use  hr

   if db is not exists then it is created 
   if db already exists then it opened

 => to find currrent database name ?

        > db 

 => how to delete current database ?

      >db.dropDatabase()

Collection commands :- 
-------------------------------

  => to see the list of collections in db ?

    >use hr
    >show collections

=> how to create collection ?

   >db.createCollection("emp")

Documents :- 
--------------------

  => to show all documents in collection ?
 
   >db.emp.find()

 => how to insert document in collection ?
 
   1  insertOne    => used to insert single document
   2  insertMany   => used to insert multiple documents 

 insertOne :- 
 -----------------
 
     db.collection.insertOne({key : value ,key : value , key : value,-----}) 

ex :- 

   >db.emp.insertOne({empno:100,ename:"vijay",sal:5000})

 insertMany :- 
 -----------------  

    db.collection.insertMany([{document1} , {document2} , {doc 3},---])

find() :-
------------

=> To see the list of documents ?

   >db.emp.find()

=> To display first 10 documents ?

  >db.emp.find().limit(10)

=>  To skip first 5 documents and display next 10 documents ?
 
  >db.emp.find().skip(5).limit(10)

=> search based on condition ?

  >db.emp.find({ename:"rahul"})
 
  >db.emp.find({empno:100})

  >db.emp.find({sal:5000})

=> search for the documents sal > 5000 ? 
 
 > db.emp.find({sal: {$lt: 7000}})   // less than
 > db.emp.find({sal: {$lte: 6000}})  // less than or equal
 > db.emp.find({sal: {$gt: 5000}})   // greater than
 > db.emp.find({sal: {$gte: 6000}})  // greater than or equal
 > db.emp.find({sal: {$ne:5000}})    // not equal

=> no of documents matching to the condition ?
 




